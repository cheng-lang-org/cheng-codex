# Patch tool (codex-rs-aligned behavior with apply_patch-first fallback)

import system
import cmdline
import std/os
import std/times
import cheng/codex/common
import cheng/codex/config

var patchTempSeq: int32 = 0

fn patchTempBaseDir(): str =
    let home = codexHomeDir()
    if len(home) > 0:
        let base = os.joinPath(home, "tmp")
        if ! os.dirExists(base):
            os.createDir(base)
        return base
    if os.dirExists("/tmp"):
        return "/tmp"
    return os.getCurrentDir()

fn patchNextTempPath(): str =
    patchTempSeq = patchTempSeq + 1
    let ts = int64ToStr(times.toUnix(times.now()))
    var name = "apply_patch-"
    name = name + ts
    name = name + "-"
    name = name + intToStr(patchTempSeq)
    name = name + ".patch"
    return os.joinPath(patchTempBaseDir(), name)

fn writeTempPatch(patchText: str): str =
    if len(patchText) == 0:
        return ""
    let path = patchNextTempPath()
    if len(path) == 0:
        return ""
    os.writeFile(path, patchText)
    return path

fn patchToolOutputLocal(res: os.ExecCmdResult): str =
    var output = res.output
    if output == nil:
        output = ""
    return output

fn patchExecLocal(cmd: str, root: str): ToolResult =
    let opts = {os.poStdErrToStdOut, os.poUsePath, os.poEvalCommand}
    let res = os.execCmdEx(cmd, opts, root)
    let exitCode = int32(res.exitCode)
    return makeToolResult(exitCode == 0, patchToolOutputLocal(res), exitCode)

fn patchCommandExists(name: str, root: str): bool =
    if len(name) == 0:
        return false
    let check = patchExecLocal("command -v " + shellQuote(name) + " >/dev/null 2>&1", root)
    return check.exitCode == 0

fn patchCurrentExeName(): str =
    let raw = trimLine($ cmdline.paramStr(0))
    if len(raw) == 0:
        return ""
    var exe = normalizePolicy(os.extractFilename(raw))
    if len(exe) > 4 && endsWithSuffix(exe, ".exe"):
        exe = __cheng_slice_string(exe, 0, len(exe) - 5, false)
    if len(exe) > 4 && endsWithSuffix(exe, ".bat"):
        exe = __cheng_slice_string(exe, 0, len(exe) - 5, false)
    if len(exe) > 4 && endsWithSuffix(exe, ".cmd"):
        exe = __cheng_slice_string(exe, 0, len(exe) - 5, false)
    return exe

fn patchRunningAsApplyPatchAlias(): bool =
    let exe = patchCurrentExeName()
    return exe == "apply_patch" || exe == "applypatch"

fn runApplyPatchBinary(patchPath: str, root: str, commandName: str): ToolResult =
    if len(patchPath) == 0 || len(commandName) == 0:
        return makeToolResult(false, "patch write failed", -1)
    let cmd = commandName + " < " + shellQuote(patchPath)
    return patchExecLocal(cmd, root)

fn runGitApply(patchPath: str, root: str): ToolResult =
    if len(patchPath) == 0:
        return makeToolResult(false, "patch write failed", -1)
    let cmd = "git apply --whitespace=nowarn " + shellQuote(patchPath)
    return patchExecLocal(cmd, root)

fn runPosixPatch(patchPath: str, root: str): ToolResult =
    if len(patchPath) == 0:
        return makeToolResult(false, "patch write failed", -1)
    let cmd = "patch -p0 -i " + shellQuote(patchPath)
    return patchExecLocal(cmd, root)

fn runPatchTool(patchText: str, root: str): ToolResult =
    if len(patchText) == 0:
        return makeToolResult(false, "empty patch", -1)
    let patchPath = writeTempPatch(patchText)
    if len(patchPath) == 0:
        return makeToolResult(false, "patch write failed", -1)

    # Match codex-rs intent: use `apply_patch` tool path when available.
    # When already running under apply_patch/applypatch argv0, skip the
    # helper-binary path to avoid recursive self-invocation.
    let allowHelperBinary = ! patchRunningAsApplyPatchAlias()
    var result: ToolResult
    if allowHelperBinary && patchCommandExists("apply_patch", root):
        result = runApplyPatchBinary(patchPath, root, "apply_patch")
    elif allowHelperBinary && patchCommandExists("applypatch", root):
        result = runApplyPatchBinary(patchPath, root, "applypatch")
    else:
        # Fallback for environments without arg0 shims.
        result = runGitApply(patchPath, root)
        if ! result.ok:
            result = runPosixPatch(patchPath, root)

    if os.fileExists(patchPath):
        os.removeFile(patchPath)

    return result
