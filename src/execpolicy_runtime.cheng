# Execpolicy runtime evaluation + amendments

import std/os
import seqs
type
    ExecPolicyRuleMatch =
        isPolicy: bool
        decision: str
        matchedPrefix: str[]
        command: str[]

    ExecApprovalRequirement =
        kind: int32
        reason: str
        bypassSandbox: bool
        proposedExecpolicyAmendment: str[]

const
    execReqSkip = 0
    execReqNeedsApproval = 1
    execReqForbidden = 2

const
    EXEC_POLICY_FORBIDDEN_REASON = "execpolicy forbids this command"
    EXEC_POLICY_PROMPT_CONFLICT_REASON = "execpolicy requires approval for this command, but AskForApproval is set to Never"
    EXEC_POLICY_PROMPT_REASON = "execpolicy requires approval for this command"

fn execPolicyFeatureEnabled(): bool =
    # Default off for stability; enable explicitly via config.toml:
    #   features.exec_policy = true
    return configBoolValue("features.exec_policy", false)

fn listRuleFiles(dirPath: str): str[] =
    var out: str[] = []
    if len(dirPath) == 0 || ! os.dirExists(dirPath):
        return out
    let entries: seq_WalkDirEntry = os.walkDir(dirPath)
    for i in 0..<entries.len:
        let entry: WalkDirEntry = os_get_WalkDirEntry(entries, i)
        let kind: PathComponent = entry.kind
        let path: str = entry.path
        if kind == pcFile || kind == pcLinkToFile:
            if endsWithSuffix(path, ".rules"):
                add(out, path)
    # simple bubble sort for stability
    var swapped = true
    while swapped:
        swapped = false
        var j: int32 = 0
        while j + 1 < len(out):
            if out[j] > out[j + 1]:
                let tmp = out[j]
                out[j] = out[j + 1]
                out[j + 1] = tmp
                swapped = true
            j = j + 1
    return out

fn loadExecPolicyRules(outRules: var ExecPolicyRule[], err: var str): bool =
    err = ""
    outRules = []
    if ! execPolicyFeatureEnabled():
        return true
    let rulesDir = os.joinPath(codexHomeDir(), "rules")
    let paths = listRuleFiles(rulesDir)
    var parseErr = ""
    if ! parseExecPolicyFiles(paths, outRules, parseErr):
        err = parseErr
        return false
    return true

fn isPolicyMatch(ruleMatch: ExecPolicyRuleMatch): bool =
    return ruleMatch.isPolicy

fn hasPolicyMatchWithDecision(matches: ExecPolicyRuleMatch[], decision: str): bool =
    for i in 0..<len(matches):
        if matches[i].isPolicy && normalizePolicy(matches[i].decision) == decision:
            return true
    return false

fn firstHeuristicMatch(matches: ExecPolicyRuleMatch[], decision: str): str[] =
    var empty: str[] = []
    for i in 0..<len(matches):
        let item = matches[i]
        if ! item.isPolicy && normalizePolicy(item.decision) == decision:
            return item.command
    return empty

fn tryDeriveExecpolicyAmendmentForPrompt(matches: ExecPolicyRuleMatch[]): str[] =
    var empty: str[] = []
    if hasPolicyMatchWithDecision(matches, "prompt"):
        return empty
    return firstHeuristicMatch(matches, "prompt")

fn tryDeriveExecpolicyAmendmentForAllow(matches: ExecPolicyRuleMatch[]): str[] =
    var empty: str[] = []
    for i in 0..<len(matches):
        if matches[i].isPolicy:
            return empty
    return firstHeuristicMatch(matches, "allow")

fn derivePromptReason(matches: ExecPolicyRuleMatch[]): str =
    if hasPolicyMatchWithDecision(matches, "prompt"):
        return EXEC_POLICY_PROMPT_REASON
    return ""

fn appendExecPolicyAllowRule(prefixTokens: str[], err: var str): bool =
    err = ""
    if ! execPolicyFeatureEnabled():
        err = "execpolicy feature is disabled"
        return false
    if len(prefixTokens) == 0:
        err = "empty execpolicy prefix"
        return false
    let rulesDir = os.joinPath(codexHomeDir(), "rules")
    if ! os.dirExists(rulesDir):
        os.createDir(rulesDir)
    let rulesPath = os.joinPath(rulesDir, "default.rules")
    var tokensJson: str[] = []
    for i in 0..<len(prefixTokens):
        add(tokensJson, jstrString(prefixTokens[i]))
    let pattern = "[" + joinWithComma(tokensJson) + "]"
    let ruleLine = "prefix_rule(pattern=" + pattern + ", decision=\"allow\")"
    var content = ""
    if os.fileExists(rulesPath):
        let existing = os.readFile(rulesPath)
        if existing != nil:
            content = existing
    if len(content) > 0 && content[len(content) - 1] != '\n':
        content = content + "\n"
    content = content + ruleLine + "\n"
    os.writeFile(rulesPath, content)
    return true

fn evaluateExecPolicyRequirement(commandTokens: str[], approvalPolicy: str, sandboxMode: str, sandboxPermissions: str, err: var str): ExecApprovalRequirement =
    err = ""
    if ! execPolicyFeatureEnabled():
        return ExecApprovalRequirement(kind: execReqSkip, reason: "", bypassSandbox: false, proposedExecpolicyAmendment: [])
    var rules: ExecPolicyRule[]
    var loadErr = ""
    if ! loadExecPolicyRules(rules, loadErr):
        let reason = "execpolicy parse error: " + loadErr
        err = reason
        return ExecApprovalRequirement(kind: execReqForbidden, reason: reason, bypassSandbox: false, proposedExecpolicyAmendment: [])
    var commands: str[][] = parseShellLcPlainCommands(commandTokens)
    if len(commands) == 0:
        commands = []
        add(commands, commandTokens)
    var matches: ExecPolicyRuleMatch[] = []
    for cidx in 0..<len(commands):
        let cmd = commands[cidx]
        var matchedAny = false
        for ridx in 0..<len(rules):
            let rule = rules[ridx]
            let prefix = ruleMatchPrefix(rule, cmd)
            if len(prefix) > 0:
                matchedAny = true
                add(matches, ExecPolicyRuleMatch(isPolicy: true, decision: rule.decision, matchedPrefix: prefix, command: cmd))
        if ! matchedAny:
            let needs = requiresInitialApproval(approvalPolicy, sandboxMode, cmd, sandboxPermissions)
            var decision: str = "allow"
            if needs:
                decision = "prompt"
            add(matches, ExecPolicyRuleMatch(isPolicy: false, decision: decision, matchedPrefix: [], command: cmd))
    var bestDecision = "allow"
    var bestRank: int32 = 0
    for midx in 0..<len(matches):
        let decision = normalizePolicy(matches[midx].decision)
        let rank = decisionRank(decision)
        if rank > bestRank:
            bestRank = rank
            bestDecision = decision
    if bestDecision == "forbidden":
        return ExecApprovalRequirement(kind: execReqForbidden, reason: EXEC_POLICY_FORBIDDEN_REASON, bypassSandbox: false, proposedExecpolicyAmendment: [])
    if bestDecision == "prompt":
        let normalizedPolicy = normalizePolicy(trimLine(approvalPolicy))
        if normalizedPolicy == "never":
            return ExecApprovalRequirement(kind: execReqForbidden, reason: EXEC_POLICY_PROMPT_CONFLICT_REASON, bypassSandbox: false, proposedExecpolicyAmendment: [])
        let amendment = if execPolicyFeatureEnabled(): tryDeriveExecpolicyAmendmentForPrompt(matches) else: []
        return ExecApprovalRequirement(kind: execReqNeedsApproval, reason: derivePromptReason(matches), bypassSandbox: false, proposedExecpolicyAmendment: amendment)
    let bypass = hasPolicyMatchWithDecision(matches, "allow")
    let amendment = if execPolicyFeatureEnabled(): tryDeriveExecpolicyAmendmentForAllow(matches) else: []
    return ExecApprovalRequirement(kind: execReqSkip, reason: "", bypassSandbox: bypass, proposedExecpolicyAmendment: amendment)
