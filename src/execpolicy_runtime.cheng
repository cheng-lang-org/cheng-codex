# Execpolicy runtime evaluation + amendments

import system
import std/os
import seqs
type
    ExecPolicyRuleMatch =
        isPolicy: bool
        decision: str
        matchedPrefix: seq[str]
        command: seq[str]

    ExecApprovalRequirement =
        kind: int32
        reason: str
        bypassSandbox: bool
        proposedExecpolicyAmendment: seq[str]

const
    execReqSkip = 0
    execReqNeedsApproval = 1
    execReqForbidden = 2

const
    EXEC_POLICY_FORBIDDEN_REASON = "execpolicy forbids this command"
    EXEC_POLICY_PROMPT_CONFLICT_REASON = "execpolicy requires approval for this command, but AskForApproval is set to Never"
    EXEC_POLICY_PROMPT_REASON = "execpolicy requires approval for this command"

fn execPolicyFeatureEnabled(): bool =
    # Default off for stability; enable explicitly via config.toml:
    #   features.exec_policy = true
    return configBoolValue("features.exec_policy", false)

fn listRuleFiles(dirPath: str): seq[str] =
    var out: seq[str] = newSeq[str]()
    if len(dirPath) == 0 || ! os.dirExists(dirPath):
        return out
    let entries: seq_WalkDirEntry = os.walkDir(dirPath)
    var i: int32 = 0
    while i < entries.len:
        let entry: WalkDirEntry = get_WalkDirEntry(entries, i)
        let kind: PathComponent = entry.kind
        let path: str = entry.path
        if kind == pcFile || kind == pcLinkToFile:
            if endsWithSuffix(path, ".rules"):
                seqAdd(out, path)
        i = i + 1
    # simple bubble sort for stability
    var swapped = true
    while swapped:
        swapped = false
        var j: int32 = 0
        while j + 1 < len(out):
            if out[j] > out[j + 1]:
                let tmp = out[j]
                out[j] = out[j + 1]
                out[j + 1] = tmp
                swapped = true
            j = j + 1
    return out

fn loadExecPolicyRules(outRules: var seq[ExecPolicyRule], err: var str): bool =
    err = ""
    outRules = newSeq[ExecPolicyRule]()
    if ! execPolicyFeatureEnabled():
        return true
    let rulesDir = os.joinPath(codexHomeDir(), "rules")
    let paths = listRuleFiles(rulesDir)
    var parseErr = ""
    if ! parseExecPolicyFiles(paths, outRules, parseErr):
        err = parseErr
        return false
    return true

fn isPolicyMatch(ruleMatch: ExecPolicyRuleMatch): bool =
    return ruleMatch.isPolicy

fn hasPolicyMatchWithDecision(matches: seq[ExecPolicyRuleMatch], decision: str): bool =
    var i: int32 = 0
    while i < len(matches):
        if matches[i].isPolicy && normalizePolicy(matches[i].decision) == decision:
            return true
        i = i + 1
    return false

fn firstHeuristicMatch(matches: seq[ExecPolicyRuleMatch], decision: str): seq[str] =
    var empty: seq[str] = newSeq[str]()
    var i: int32 = 0
    while i < len(matches):
        let item = matches[i]
        if ! item.isPolicy && normalizePolicy(item.decision) == decision:
            return item.command
        i = i + 1
    return empty

fn tryDeriveExecpolicyAmendmentForPrompt(matches: seq[ExecPolicyRuleMatch]): seq[str] =
    var empty: seq[str] = newSeq[str]()
    if hasPolicyMatchWithDecision(matches, "prompt"):
        return empty
    return firstHeuristicMatch(matches, "prompt")

fn tryDeriveExecpolicyAmendmentForAllow(matches: seq[ExecPolicyRuleMatch]): seq[str] =
    var empty: seq[str] = newSeq[str]()
    var i: int32 = 0
    while i < len(matches):
        if matches[i].isPolicy:
            return empty
        i = i + 1
    return firstHeuristicMatch(matches, "allow")

fn derivePromptReason(matches: seq[ExecPolicyRuleMatch]): str =
    if hasPolicyMatchWithDecision(matches, "prompt"):
        return EXEC_POLICY_PROMPT_REASON
    return ""

fn appendExecPolicyAllowRule(prefixTokens: seq[str], err: var str): bool =
    err = ""
    if ! execPolicyFeatureEnabled():
        err = "execpolicy feature is disabled"
        return false
    if len(prefixTokens) == 0:
        err = "empty execpolicy prefix"
        return false
    let rulesDir = os.joinPath(codexHomeDir(), "rules")
    if ! os.dirExists(rulesDir):
        os.createDir(rulesDir)
    let rulesPath = os.joinPath(rulesDir, "default.rules")
    var tokensJson: seq[str] = newSeq[str]()
    var i: int32 = 0
    while i < len(prefixTokens):
        seqAdd(tokensJson, jstrString(prefixTokens[i]))
        i = i + 1
    let pattern = "[" + joinWithComma(tokensJson) + "]"
    let ruleLine = "prefix_rule(pattern=" + pattern + ", decision=\"allow\")"
    var content = ""
    if os.fileExists(rulesPath):
        let existing = os.readFile(rulesPath)
        if existing != nil:
            content = existing
    if len(content) > 0 && content[len(content) - 1] != '\n':
        content = content + "\n"
    content = content + ruleLine + "\n"
    os.writeFile(rulesPath, content)
    return true

fn evaluateExecPolicyRequirement(commandTokens: seq[str], approvalPolicy: str, sandboxMode: str, sandboxPermissions: str, err: var str): ExecApprovalRequirement =
    err = ""
    if ! execPolicyFeatureEnabled():
        return ExecApprovalRequirement(kind: execReqSkip, reason: "", bypassSandbox: false, proposedExecpolicyAmendment: newSeq[str]())
    var rules: seq[ExecPolicyRule]
    var loadErr = ""
    if ! loadExecPolicyRules(rules, loadErr):
        let reason = "execpolicy parse error: " + loadErr
        err = reason
        return ExecApprovalRequirement(kind: execReqForbidden, reason: reason, bypassSandbox: false, proposedExecpolicyAmendment: newSeq[str]())
    var commands: seq[seq[str]] = parseShellLcPlainCommands(commandTokens)
    if len(commands) == 0:
        commands = newSeq[seq[str]]()
        seqAdd(commands, commandTokens)
    var matches: seq[ExecPolicyRuleMatch] = newSeq[ExecPolicyRuleMatch]()
    var cidx: int32 = 0
    while cidx < len(commands):
        let cmd = commands[cidx]
        var matchedAny = false
        var ridx: int32 = 0
        while ridx < len(rules):
            let rule = rules[ridx]
            let prefix = ruleMatchPrefix(rule, cmd)
            if len(prefix) > 0:
                matchedAny = true
                seqAdd(matches, ExecPolicyRuleMatch(isPolicy: true, decision: rule.decision, matchedPrefix: prefix, command: cmd))
            ridx = ridx + 1
        if ! matchedAny:
            let needs = requiresInitialApproval(approvalPolicy, sandboxMode, cmd, sandboxPermissions)
            var decision: str = "allow"
            if needs:
                decision = "prompt"
            seqAdd(matches, ExecPolicyRuleMatch(isPolicy: false, decision: decision, matchedPrefix: newSeq[str](), command: cmd))
        cidx = cidx + 1
    var bestDecision = "allow"
    var bestRank: int32 = 0
    var midx: int32 = 0
    while midx < len(matches):
        let decision = normalizePolicy(matches[midx].decision)
        let rank = decisionRank(decision)
        if rank > bestRank:
            bestRank = rank
            bestDecision = decision
        midx = midx + 1
    if bestDecision == "forbidden":
        return ExecApprovalRequirement(kind: execReqForbidden, reason: EXEC_POLICY_FORBIDDEN_REASON, bypassSandbox: false, proposedExecpolicyAmendment: newSeq[str]())
    if bestDecision == "prompt":
        let normalizedPolicy = normalizePolicy(trimLine(approvalPolicy))
        if normalizedPolicy == "never":
            return ExecApprovalRequirement(kind: execReqForbidden, reason: EXEC_POLICY_PROMPT_CONFLICT_REASON, bypassSandbox: false, proposedExecpolicyAmendment: newSeq[str]())
        let amendment = if execPolicyFeatureEnabled(): tryDeriveExecpolicyAmendmentForPrompt(matches) else: newSeq[str]()
        return ExecApprovalRequirement(kind: execReqNeedsApproval, reason: derivePromptReason(matches), bypassSandbox: false, proposedExecpolicyAmendment: amendment)
    let bypass = hasPolicyMatchWithDecision(matches, "allow")
    let amendment = if execPolicyFeatureEnabled(): tryDeriveExecpolicyAmendmentForAllow(matches) else: newSeq[str]()
    return ExecApprovalRequirement(kind: execReqSkip, reason: "", bypassSandbox: bypass, proposedExecpolicyAmendment: amendment)
