# Shell tool argument parsing

import system
import seqs
type
    ShellToolArgs =
        commandText: str
        commandTokens: str[]
        workdir: str
        sandboxPermissions: str
        justification: str
        timeoutMs: int32
        login: bool
        hasLogin: bool

fn jsonExtractStringArrayAfter(payload: str, key: str, startIdx: int32): str[] =
    var outVal: str[] = []
    let keyIdx = jsonFindKeyAfter(payload, key, startIdx)
    if keyIdx < 0:
        return outVal
    var idx: int32 = indexOfSubstr(payload, ":", keyIdx + len(key) + 2)
    if idx < 0:
        return outVal
    idx = jsonSkipSpaces(payload, idx + 1)
    if idx >= len(payload) || payload[idx] != '[':
        return outVal
    var cursor = idx + 1
    for idx in cursor..<len(payload):
        if idx < cursor:
            continue
        cursor = jsonSkipSpaces(payload, idx)
        if cursor >= len(payload):
            break
        let ch = payload[cursor]
        if ch == ']':
            break
        if ch != '"':
            break
        var value = ""
        let valueStart = cursor + 1
        var nextCursor = valueStart
        var valueSkipUntil: int32 = valueStart - 1
        for valueIdx in valueStart..<len(payload):
            if valueIdx <= valueSkipUntil:
                continue
            let c = payload[valueIdx]
            if c == '\\' && valueIdx + 1 < len(payload):
                let next = payload[valueIdx + 1]
                if next == 'n':
                    value = value + "\n"
                elif next == 'r':
                    value = value + "\r"
                elif next == 't':
                    value = value + "\t"
                else:
                    value = value + $ next
                valueSkipUntil = valueIdx + 1
                nextCursor = valueIdx + 2
                continue
            if c == '"':
                nextCursor = valueIdx + 1
                break
            value = value + $ c
            nextCursor = valueIdx + 1
        add(outVal, value)
        cursor = nextCursor
        var sawSeparator = false
        for sepIdx in cursor..<len(payload):
            let sep = payload[sepIdx]
            if sep == ',':
                cursor = sepIdx + 1
                sawSeparator = true
                break
            if sep == ']':
                cursor = sepIdx
                sawSeparator = true
                break
            cursor = sepIdx + 1
        if ! sawSeparator:
            break
    return outVal

fn jsonExtractBool(payload: str, key: str, defaultValue: bool): bool =
    let keyIdx = jsonFindKeyAfter(payload, key, 0)
    if keyIdx < 0:
        return defaultValue
    var idx: int32 = indexOfSubstr(payload, ":", keyIdx + len(key) + 2)
    if idx < 0:
        return defaultValue
    idx = jsonSkipSpaces(payload, idx + 1)
    if idx >= len(payload):
        return defaultValue
    if hasPrefix(__cheng_slice_string(payload, idx, len(payload) - 1, false), "true"):
        return true
    if hasPrefix(__cheng_slice_string(payload, idx, len(payload) - 1, false), "false"):
        return false
    return defaultValue

fn parseShellToolArgs(arguments: str): ShellToolArgs =
    var outCommandText = ""
    var outCommandTokens: str[] = []
    var outWorkdir = ""
    var outSandboxPermissions = ""
    var outJustification = ""
    var outTimeoutMs: int32 = -1
    var outLogin = false
    var outHasLogin = false
    let cmdTokens = jsonExtractStringArray(arguments, "command")
    if len(cmdTokens) > 0:
        outCommandTokens = cmdTokens
        var cmdText = ""
        for i in 0..<len(cmdTokens):
            let part = shellQuote(cmdTokens[i])
            if len(cmdText) == 0:
                cmdText = part
            else:
                cmdText = cmdText + " " + part
        outCommandText = cmdText
    else:
        let cmdText = jsonExtractString(arguments, "command")
        var alt: str = ""
        if len(cmdText) > 0:
            alt = cmdText
        else:
            alt = jsonExtractString(arguments, "cmd")
        outCommandText = alt
        if len(alt) > 0:
            var tokens: str[]
            var splitErr = ""
            if splitCommandTokens(alt, tokens, splitErr):
                outCommandTokens = tokens
    let workdir = jsonExtractString(arguments, "workdir")
    if len(workdir) > 0:
        outWorkdir = workdir
    else:
        outWorkdir = jsonExtractString(arguments, "cwd")
    let perm = jsonExtractString(arguments, "sandbox_permissions")
    if len(perm) > 0:
        outSandboxPermissions = perm
    else:
        outSandboxPermissions = jsonExtractString(arguments, "sandboxPermissions")
    outJustification = jsonExtractString(arguments, "justification")
    if len(outJustification) == 0:
        outJustification = jsonExtractString(arguments, "reason")
    let timeoutVal = jsonExtractInt(arguments, "timeout_ms", -1)
    if timeoutVal >= 0:
        outTimeoutMs = timeoutVal
    else:
        let timeoutAlt = jsonExtractInt(arguments, "timeout", -1)
        if timeoutAlt >= 0:
            outTimeoutMs = timeoutAlt
        else:
            let timeoutCamel = jsonExtractInt(arguments, "timeoutMs", -1)
            if timeoutCamel >= 0:
                outTimeoutMs = timeoutCamel
    let loginKey = jsonFindKeyAfter(arguments, "login", 0)
    if loginKey >= 0:
        outLogin = jsonExtractBool(arguments, "login", true)
        outHasLogin = true
    return ShellToolArgs(
        commandText: outCommandText,
        commandTokens: outCommandTokens,
        workdir: outWorkdir,
        sandboxPermissions: outSandboxPermissions,
        justification: outJustification,
        timeoutMs: outTimeoutMs,
        login: outLogin,
        hasLogin: outHasLogin
    )
