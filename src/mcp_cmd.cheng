# MCP command support

import std/os
import seqs
import cheng/codex/common

type
    McpStringPair =
        key: str
        value: str

    McpStdioRow =
        name: str
        command: str
        args: str
        env: str
        cwd: str
        status: str
        auth: str

    McpHttpRow =
        name: str
        url: str
        bearerTokenVar: str
        status: str
        auth: str

    McpLiteEntry =
        name: str
        command: str
        argsRaw: str
        cwd: str
        url: str
        bearerTokenEnvVar: str
        enabled: bool
        disabledReason: str
        enabledToolsRaw: str
        disabledToolsRaw: str
        startupTimeoutSec: str
        toolTimeoutSec: str

    McpServerEntry =
        name: str
        command: str
        args: str[]
        env: McpStringPair[]
        hasEnv: bool
        envVars: str[]
        cwd: str
        url: str
        bearerTokenEnvVar: str
        httpHeaders: McpStringPair[]
        hasHttpHeaders: bool
        envHttpHeaders: McpStringPair[]
        hasEnvHttpHeaders: bool
        enabled: bool
        disabledReason: str
        hasEnabledTools: bool
        enabledTools: str[]
        hasDisabledTools: bool
        disabledTools: str[]
        hasStartupTimeout: bool
        startupTimeoutSec: str
        hasToolTimeout: bool
        toolTimeoutSec: str

const
    mcpAuthUnsupported = 0
    mcpAuthNotLoggedIn = 1
    mcpAuthBearerToken = 2
    mcpAuthOAuth = 3

fn mcpEmptyServer(name: str): McpServerEntry =
    McpServerEntry(
        name: "" + name,
        command: "",
        args: [],
        env: [],
        hasEnv: false,
        envVars: [],
        cwd: "",
        url: "",
        bearerTokenEnvVar: "",
        httpHeaders: [],
        hasHttpHeaders: false,
        envHttpHeaders: [],
        hasEnvHttpHeaders: false,
        enabled: true,
        disabledReason: "",
        hasEnabledTools: false,
        enabledTools: [],
        hasDisabledTools: false,
        disabledTools: [],
        hasStartupTimeout: false,
        startupTimeoutSec: "",
        hasToolTimeout: false,
        toolTimeoutSec: ""
    )

fn mcpFindServerIndex(servers: var McpServerEntry[], name: str): int32 =
    for idx in 0..<servers.len:
        if servers[idx].name == name:
            return idx
    return -1

fn mcpGetServerIndex(servers: var McpServerEntry[], name: str): int32 =
    let existing = mcpFindServerIndex(servers, name)
    if existing >= 0:
        return existing
    let entry = mcpEmptyServer(name)
    add(servers, entry)
    return servers.len - 1

fn mcpSetPair(pairs: var McpStringPair[], key: str, value: str) =
    let keyCopy = "" + key
    let valueCopy = "" + value
    for idx in 0..<pairs.len:
        if pairs[idx].key == keyCopy:
            var item = pairs[idx]
            item.value = valueCopy
            pairs[idx] = item
            return
    add(pairs, McpStringPair(key: keyCopy, value: valueCopy))

fn mcpStrLess(a: str, b: str): bool =
    if a == nil && b == nil:
        return false
    if a == nil:
        return true
    if b == nil:
        return false
    let lenA = len(a)
    let lenB = len(b)
    let limit = if lenA < lenB: lenA else: lenB
    for idx in 0..<limit:
        let ca = a[idx]
        let cb = b[idx]
        if ca < cb:
            return true
        if ca > cb:
            return false
    return lenA < lenB

fn mcpSortPairsByKey(pairs: var McpStringPair[]) =
    for i in 0..<pairs.len:
        for j in i + 1..<pairs.len:
            if mcpStrLess(pairs[j].key, pairs[i].key):
                let tmp = pairs[i]
                pairs[i] = pairs[j]
                pairs[j] = tmp

fn mcpSortServersByName(servers: var McpServerEntry[]) =
    for i in 0..<servers.len:
        for j in i + 1..<servers.len:
            if mcpStrLess(servers[j].name, servers[i].name):
                let tmp = servers[i]
                servers[i] = servers[j]
                servers[j] = tmp

fn mcpSplitKeyPath(text: str): str[] =
    var outVal: str[] = []
    if text == nil:
        return outVal
    var start: int32 = 0
    for i in 0..<len(text):
        if text[i] == '.':
            if i > start:
                add(outVal, trimLine(__cheng_slice_string(text, start, i - 1, false)))
            else:
                add(outVal, "")
            start = i + 1
    if start <= len(text) - 1:
        add(outVal, trimLine(__cheng_slice_string(text, start, len(text) - 1, false)))
    elif start == len(text):
        add(outVal, "")
    return outVal

fn mcpJoinParts(parts: str[], start: int32): str =
    var out = ""
    for idx in start..<len(parts):
        if len(out) == 0:
            out = parts[idx]
        else:
            out = out + "." + parts[idx]
    return out

fn mcpSliceCopy(text: str, start: int32, stop: int32): str =
    if text == nil || len(text) == 0:
        return ""
    if start < 0 || stop < start || start >= len(text):
        return ""
    var last = stop
    if last >= len(text):
        last = len(text) - 1
    var out = ""
    for idx in start..last:
        let ch = text[idx]
        out = out + $ ch
    return out

fn mcpTrimCopy(text: str): str =
    if text == nil || len(text) == 0:
        return ""
    var start: int32 = 0
    for probe in 0..<len(text):
        let ch = text[probe]
        if ch == ' ' || ch == '\t' || ch == '\r' || ch == '\n':
            start = probe + 1
        else:
            start = probe
            break
    if start >= len(text):
        return ""
    var stop: int32 = len(text) - 1
    for rev in 0..<len(text):
        let idx: int32 = len(text) - 1 - rev
        if idx < start:
            break
        let ch = text[idx]
        if ch == ' ' || ch == '\t' || ch == '\r' || ch == '\n':
            stop = idx - 1
        else:
            stop = idx
            break
    return mcpSliceCopy(text, start, stop)

fn mcpStripInlineCommentCopy(line: str): str =
    if line == nil || len(line) == 0:
        return ""
    var out = ""
    var inString = false
    var escaped = false
    for idx in 0..<len(line):
        let ch = line[idx]
        if inString:
            if escaped:
                escaped = false
            elif ch == '\\':
                escaped = true
            elif ch == '"':
                inString = false
            out = out + $ ch
            continue
        if ch == '"':
            inString = true
            out = out + $ ch
            continue
        if ch == '#':
            break
        out = out + $ ch
    return mcpTrimCopy(out)

fn mcpCanonicalKey(text: str): str =
    let trimmed = mcpTrimCopy(text)
    var out = ""
    for idx in 0..<len(trimmed):
        let ch = trimmed[idx]
        if ch >= 'A' && ch <= 'Z':
            out = out + $ char(ch + 32)
        elif ch == '-':
            out = out + "_"
        elif ch == ' ' || ch == '\t' || ch == '\r' || ch == '\n':
            ch
        else:
            out = out + $ ch
    return out

fn mcpParseStringValueSimple(raw: str): str =
    let trimmed = "" + raw
    if len(trimmed) < 2:
        return trimmed
    if trimmed[0] != '"' || trimmed[len(trimmed) - 1] != '"':
        return trimmed
    var out = ""
    let stop = len(trimmed) - 1
    var skipUntil: int32 = 0
    for idx in 1..<stop:
        if idx <= skipUntil:
            continue
        let ch = trimmed[idx]
        if ch == '\\' && idx + 1 < stop:
            let next = trimmed[idx + 1]
            if next == 'n':
                out = out + "\n"
            elif next == 'r':
                out = out + "\r"
            elif next == 't':
                out = out + "\t"
            else:
                out = out + $ next
            skipUntil = idx + 1
            continue
        out = out + $ ch
    return out

fn mcpParseStringArraySimple(raw: str): str[] =
    var out: str[] = []
    let trimmed = mcpTrimCopy(raw)
    if len(trimmed) == 0:
        return out
    if trimmed[0] != '[':
        let one = mcpParseStringValueSimple(trimmed)
        if len(one) > 0:
            add(out, one)
        return out
    var cursor: int32 = 1
    for idx in cursor..<len(trimmed):
        if idx < cursor:
            continue
        cursor = idx
        for scan in cursor..<len(trimmed):
            let c = trimmed[scan]
            if c == ' ' || c == '\t' || c == '\r' || c == '\n':
                cursor = scan + 1
                continue
            cursor = scan
            break
        if cursor >= len(trimmed) || trimmed[cursor] == ']':
            break
        if trimmed[cursor] == '"':
            var item = ""
            var nextCursor = cursor + 1
            var skipUntil: int32 = cursor
            for scan in cursor + 1..<len(trimmed):
                if scan <= skipUntil:
                    continue
                let c = trimmed[scan]
                if c == '\\' && scan + 1 < len(trimmed):
                    let next = trimmed[scan + 1]
                    if next == 'n':
                        item = item + "\n"
                    elif next == 'r':
                        item = item + "\r"
                    elif next == 't':
                        item = item + "\t"
                    else:
                        item = item + $ next
                    skipUntil = scan + 1
                    nextCursor = scan + 2
                    continue
                if c == '"':
                    nextCursor = scan + 1
                    break
                item = item + $ c
                nextCursor = scan + 1
            if len(item) > 0:
                add(out, item)
            cursor = nextCursor
        else:
            var item = ""
            var nextCursor = cursor
            for scan in cursor..<len(trimmed):
                let c = trimmed[scan]
                if c == ',' || c == ']':
                    nextCursor = scan
                    break
                item = item + $ c
                nextCursor = scan + 1
            item = mcpTrimCopy(item)
            if len(item) > 0:
                add(out, item)
            cursor = nextCursor
        var sawSep = false
        for scan in cursor..<len(trimmed):
            if trimmed[scan] == ',' || trimmed[scan] == ']':
                cursor = scan
                sawSep = true
                break
            cursor = scan + 1
        if ! sawSep:
            break
        if cursor < len(trimmed) && trimmed[cursor] == ',':
            cursor = cursor + 1
    return out

fn mcpSplitCommaList(text: str): str[] =
    var out: str[] = []
    if text == nil || len(text) == 0:
        return out
    var start: int32 = 0
    for i in 0..len(text):
        if i == len(text) || text[i] == ',':
            if i > start:
                let part = trimLine(__cheng_slice_string(text, start, i - 1, false))
                if len(part) > 0:
                    add(out, part)
            start = i + 1
    return out

fn mcpSplitInlineEntry(entry: str, outKey: var str, outValue: var str, err: var str): bool =
    err = ""
    var inString = false
    var escaped = false
    var braceDepth: int32 = 0
    var bracketDepth: int32 = 0
    for idx in 0..<len(entry):
        let ch = entry[idx]
        if inString:
            if escaped:
                escaped = false
            elif ch == '\\':
                escaped = true
            elif ch == '"':
                inString = false
        else:
            if ch == '"':
                inString = true
            elif ch == '{':
                braceDepth = braceDepth + 1
            elif ch == '}':
                if braceDepth > 0:
                    braceDepth = braceDepth - 1
            elif ch == '[':
                bracketDepth = bracketDepth + 1
            elif ch == ']':
                if bracketDepth > 0:
                    bracketDepth = bracketDepth - 1
            elif ch == '=' && braceDepth == 0 && bracketDepth == 0:
                var keyText = ""
                if idx > 0:
                    keyText = trimLine(__cheng_slice_string(entry, 0, idx - 1, false))
                var valText: str = ""
                if idx + 1 <= len(entry) - 1:
                    valText = trimLine(__cheng_slice_string(entry, idx + 1, len(entry) - 1, false))
                if len(keyText) == 0:
                    err = "invalid inline table entry"
                    return false
                outKey = keyText
                outValue = valText
                return true
    err = "invalid inline table entry"
    return false

fn mcpParseInlineTableEntries(raw: str, outPairs: var McpStringPair[], err: var str): bool =
    err = ""
    let trimmed = trimLine(raw)
    var pairs: McpStringPair[] = []
    var inString = false
    var escaped = false
    var braceDepth: int32 = 0
    var bracketDepth: int32 = 0
    if len(trimmed) == 0:
        outPairs = pairs
        return true
    if trimmed[0] != '{' || trimmed[len(trimmed) - 1] != '}':
        err = "invalid inline table"
        return false
    var inner: str = ""
    if len(trimmed) > 2:
        inner = __cheng_slice_string(trimmed, 1, len(trimmed) - 2, false)
    var entries: str[] = []
    var start: int32 = 0
    for idx in 0..<len(inner):
        let ch = inner[idx]
        if inString:
            if escaped:
                escaped = false
            elif ch == '\\':
                escaped = true
            elif ch == '"':
                inString = false
        else:
            if ch == '"':
                inString = true
            elif ch == '{':
                braceDepth = braceDepth + 1
            elif ch == '}':
                if braceDepth > 0:
                    braceDepth = braceDepth - 1
            elif ch == '[':
                bracketDepth = bracketDepth + 1
            elif ch == ']':
                if bracketDepth > 0:
                    bracketDepth = bracketDepth - 1
            elif ch == ',' && braceDepth == 0 && bracketDepth == 0:
                var entry = ""
                if idx > start:
                    entry = trimLine(__cheng_slice_string(inner, start, idx - 1, false))
                add(entries, entry)
                start = idx + 1
    if start <= len(inner) - 1:
        add(entries, trimLine(__cheng_slice_string(inner, start, len(inner) - 1, false)))
    elif start == len(inner):
        add(entries, "")
    for eidx in 0..<len(entries):
        let entry = entries[eidx]
        if len(entry) > 0:
            var keyText = ""
            var valText = ""
            var entryErr = ""
            if ! mcpSplitInlineEntry(entry, keyText, valText, entryErr):
                err = entryErr
                return false
            add(pairs, McpStringPair(key: keyText, value: valText))
    outPairs = pairs
    return true

fn mcpInlineTableToStringPairs(raw: str, outPairs: var McpStringPair[]): bool =
    var entries: McpStringPair[]
    var err = ""
    if ! mcpParseInlineTableEntries(raw, entries, err):
        return false
    var pairs: McpStringPair[] = []
    for idx in 0..<len(entries):
        let keyText = trimLine(entries[idx].key)
        if len(keyText) > 0:
            let valueText = parseTomlStringValue(entries[idx].value)
            add(pairs, McpStringPair(key: keyText, value: valueText))
    outPairs = pairs
    return true

fn mcpParseBoolValue(raw: str, outValue: var bool): bool =
    let norm = normalizePolicy(trimLine(raw))
    if norm == "true":
        outValue = true
        return true
    if norm == "false":
        outValue = false
        return true
    return false

fn mcpIsNumericLiteral(text: str): bool =
    let trimmed = trimLine(text)
    if len(trimmed) == 0:
        return false
    var start: int32 = 0
    if trimmed[0] == '-':
        start = 1
    var sawDigit = false
    var sawDot = false
    for idx in start..<len(trimmed):
        let ch = trimmed[idx]
        if ch >= '0' && ch <= '9':
            sawDigit = true
        elif ch == '.' && ! sawDot:
            sawDot = true
        else:
            return false
    return sawDigit

fn mcpNormalizeNumberValue(raw: str, outValue: var str): bool =
    let valueText = parseTomlStringValue(raw)
    let trimmed = trimLine(valueText)
    if ! mcpIsNumericLiteral(trimmed):
        return false
    outValue = trimmed
    return true

fn mcpSecondsFromMillis(ms: int64): str =
    if ms < 0:
        return ""
    let secs = ms / 1000
    let rem = ms % 1000
    if rem == 0:
        return int64ToStr(secs)
    var frac = intToStr(int32(rem))
    if rem < 10:
        frac = "00" + frac
    elif rem < 100:
        frac = "0" + frac
    while len(frac) > 0 && frac[len(frac) - 1] == '0':
        if len(frac) == 1:
            frac = ""
        else:
            frac = __cheng_slice_string(frac, 0, len(frac) - 2, false)
    return int64ToStr(secs) + "." + frac

fn mcpApplyEnvPairs(entry: var McpServerEntry, pairs: McpStringPair[]) =
    var envPairs = entry.env
    for idx in 0..<pairs.len:
        mcpSetPair(envPairs, pairs[idx].key, pairs[idx].value)
    entry.env = envPairs
    entry.hasEnv = true

fn mcpApplyHttpHeaderPairs(entry: var McpServerEntry, pairs: McpStringPair[]) =
    var headerPairs = entry.httpHeaders
    for idx in 0..<pairs.len:
        mcpSetPair(headerPairs, pairs[idx].key, pairs[idx].value)
    entry.httpHeaders = headerPairs
    entry.hasHttpHeaders = true

fn mcpApplyEnvHttpHeaderPairs(entry: var McpServerEntry, pairs: McpStringPair[]) =
    var headerPairs = entry.envHttpHeaders
    for idx in 0..<pairs.len:
        mcpSetPair(headerPairs, pairs[idx].key, pairs[idx].value)
    entry.envHttpHeaders = headerPairs
    entry.hasEnvHttpHeaders = true

fn mcpApplyField(servers: var McpServerEntry[], name: str, key: str, rawValue: str) =
    let idx = mcpGetServerIndex(servers, name)
    var entry = servers[idx]
    let keyNorm = normalizePolicy(trimLine(key))
    var pairs: McpStringPair[] = []
    var enabled = false
    var startupText = ""
    var toolText = ""
    if keyNorm == "command":
        entry.command = "" + parseTomlStringValue(rawValue)
    elif keyNorm == "args":
        entry.args = parseTomlStringArray(rawValue)
    elif keyNorm == "env":
        pairs = []
        if mcpInlineTableToStringPairs(rawValue, pairs):
            mcpApplyEnvPairs(entry, pairs)
    elif keyNorm == "env_vars":
        entry.envVars = parseTomlStringArray(rawValue)
    elif keyNorm == "cwd":
        entry.cwd = "" + parseTomlStringValue(rawValue)
    elif keyNorm == "url":
        entry.url = "" + parseTomlStringValue(rawValue)
    elif keyNorm == "bearer_token_env_var":
        entry.bearerTokenEnvVar = "" + parseTomlStringValue(rawValue)
    elif keyNorm == "http_headers":
        pairs = []
        if mcpInlineTableToStringPairs(rawValue, pairs):
            mcpApplyHttpHeaderPairs(entry, pairs)
    elif keyNorm == "env_http_headers":
        pairs = []
        if mcpInlineTableToStringPairs(rawValue, pairs):
            mcpApplyEnvHttpHeaderPairs(entry, pairs)
    elif keyNorm == "enabled":
        if mcpParseBoolValue(rawValue, enabled):
            entry.enabled = enabled
    elif keyNorm == "disabled_reason":
        entry.disabledReason = "" + parseTomlStringValue(rawValue)
    elif keyNorm == "enabled_tools":
        entry.enabledTools = parseTomlStringArray(rawValue)
        entry.hasEnabledTools = true
    elif keyNorm == "disabled_tools":
        entry.disabledTools = parseTomlStringArray(rawValue)
        entry.hasDisabledTools = true
    elif keyNorm == "startup_timeout_sec":
        startupText = ""
        if mcpNormalizeNumberValue(rawValue, startupText):
            entry.startupTimeoutSec = startupText
            entry.hasStartupTimeout = true
    elif keyNorm == "startup_timeout_ms":
        if ! entry.hasStartupTimeout:
            let ms = parseInt64Simple(trimLine(rawValue), -1)
            if ms >= 0:
                let secs = mcpSecondsFromMillis(ms)
                if len(secs) > 0:
                    entry.startupTimeoutSec = secs
                    entry.hasStartupTimeout = true
    elif keyNorm == "tool_timeout_sec":
        toolText = ""
        if mcpNormalizeNumberValue(rawValue, toolText):
            entry.toolTimeoutSec = toolText
            entry.hasToolTimeout = true
    servers[idx] = entry

fn mcpApplyInlineTable(servers: var McpServerEntry[], name: str, rawValue: str) =
    var entries: McpStringPair[]
    var err = ""
    if ! mcpParseInlineTableEntries(rawValue, entries, err):
        return
    for idx in 0..<len(entries):
        mcpApplyField(servers, name, entries[idx].key, entries[idx].value)

fn mcpHandleRootEntry(servers: var McpServerEntry[], keyText: str, valueText: str) =
    let parts = mcpSplitKeyPath(keyText)
    if len(parts) == 0:
        return
    let name = "" + parts[0]
    if len(parts) == 1:
        mcpApplyInlineTable(servers, name, valueText)
        return
    let field = normalizePolicy(parts[1])
    if field == "env" || field == "http_headers" || field == "env_http_headers":
        if len(parts) == 2:
            mcpApplyField(servers, name, field, valueText)
        elif len(parts) > 2:
            let mapKey = mcpJoinParts(parts, 2)
            if len(mapKey) > 0:
                let idx = mcpGetServerIndex(servers, name)
                var entry = servers[idx]
                let value = "" + parseTomlStringValue(valueText)
                if field == "env":
                    var envPairs = entry.env
                    mcpSetPair(envPairs, "" + mapKey, value)
                    entry.env = envPairs
                    entry.hasEnv = true
                elif field == "http_headers":
                    var headerPairs = entry.httpHeaders
                    mcpSetPair(headerPairs, "" + mapKey, value)
                    entry.httpHeaders = headerPairs
                    entry.hasHttpHeaders = true
                elif field == "env_http_headers":
                    var envHeaderPairs = entry.envHttpHeaders
                    mcpSetPair(envHeaderPairs, "" + mapKey, value)
                    entry.envHttpHeaders = envHeaderPairs
                    entry.hasEnvHttpHeaders = true
                servers[idx] = entry
        return
    mcpApplyField(servers, name, field, valueText)

fn mcpHandleServerSection(servers: var McpServerEntry[], section: str, keyText: str, valueText: str) =
    let parts = mcpSplitKeyPath(section)
    if len(parts) < 2:
        return
    let name = "" + parts[1]
    if len(parts) == 2:
        mcpApplyField(servers, name, keyText, valueText)
        return
    if len(parts) == 3:
        let sub = normalizePolicy(parts[2])
        if sub == "env" || sub == "http_headers" || sub == "env_http_headers":
            let mapKey = trimLine(keyText)
            if len(mapKey) == 0:
                return
            let idx = mcpGetServerIndex(servers, name)
            var entry = servers[idx]
            let value = "" + parseTomlStringValue(valueText)
            if sub == "env":
                var envPairs = entry.env
                mcpSetPair(envPairs, "" + mapKey, value)
                entry.env = envPairs
                entry.hasEnv = true
            elif sub == "http_headers":
                var headerPairs = entry.httpHeaders
                mcpSetPair(headerPairs, "" + mapKey, value)
                entry.httpHeaders = headerPairs
                entry.hasHttpHeaders = true
            elif sub == "env_http_headers":
                var envHeaderPairs = entry.envHttpHeaders
                mcpSetPair(envHeaderPairs, "" + mapKey, value)
                entry.envHttpHeaders = envHeaderPairs
                entry.hasEnvHttpHeaders = true
            servers[idx] = entry
        return

fn mcpHandleGlobalEntry(servers: var McpServerEntry[], keyText: str, valueText: str) =
    if ! hasPrefix(keyText, "mcp_servers."):
        return
    let suffix = dropPrefix(keyText, "mcp_servers.")
    let parts = mcpSplitKeyPath(suffix)
    if len(parts) == 0:
        return
    let name = "" + parts[0]
    if len(parts) == 1:
        mcpApplyInlineTable(servers, name, valueText)
        return
    let field = normalizePolicy(parts[1])
    if field == "env" || field == "http_headers" || field == "env_http_headers":
        if len(parts) == 2:
            mcpApplyField(servers, name, field, valueText)
        elif len(parts) > 2:
            let mapKey = mcpJoinParts(parts, 2)
            if len(mapKey) > 0:
                let idx = mcpGetServerIndex(servers, name)
                var entry = servers[idx]
                let value = "" + parseTomlStringValue(valueText)
                if field == "env":
                    var envPairs = entry.env
                    mcpSetPair(envPairs, "" + mapKey, value)
                    entry.env = envPairs
                    entry.hasEnv = true
                elif field == "http_headers":
                    var headerPairs = entry.httpHeaders
                    mcpSetPair(headerPairs, "" + mapKey, value)
                    entry.httpHeaders = headerPairs
                    entry.hasHttpHeaders = true
                elif field == "env_http_headers":
                    var envHeaderPairs = entry.envHttpHeaders
                    mcpSetPair(envHeaderPairs, "" + mapKey, value)
                    entry.envHttpHeaders = envHeaderPairs
                    entry.hasEnvHttpHeaders = true
                servers[idx] = entry
        return
    mcpApplyField(servers, name, field, valueText)

fn mcpFindServerIndexSimple(servers: var McpServerEntry[], name: str): int32 =
    for idx in 0..<servers.len:
        if servers[idx].name == name:
            return idx
    return -1

fn mcpEnsureServerIndexSimple(servers: var McpServerEntry[], name: str): int32 =
    let found = mcpFindServerIndexSimple(servers, name)
    if found >= 0:
        return found
    add(servers, mcpEmptyServer(name))
    return servers.len - 1

fn mcpLiteEmpty(name: str): McpLiteEntry =
    McpLiteEntry(
        name: "" + name,
        command: "",
        argsRaw: "",
        cwd: "",
        url: "",
        bearerTokenEnvVar: "",
        enabled: true,
        disabledReason: "",
        enabledToolsRaw: "",
        disabledToolsRaw: "",
        startupTimeoutSec: "",
        toolTimeoutSec: ""
    )

fn mcpLiteFindIndex(items: var McpLiteEntry[], name: str): int32 =
    for i in 0..<items.len:
        if items[i].name == name:
            return i
    return -1

fn mcpLiteEnsureIndex(items: var McpLiteEntry[], name: str): int32 =
    let found = mcpLiteFindIndex(items, name)
    if found >= 0:
        return found
    add(items, mcpLiteEmpty(name))
    return items.len - 1

fn mcpLiteSortByName(items: var McpLiteEntry[]) =
    for i in 0..<items.len:
        for j in i + 1..<items.len:
            if mcpStrLess(items[j].name, items[i].name):
                let tmp = items[i]
                items[i] = items[j]
                items[j] = tmp

fn mcpLiteTransportType(entry: McpLiteEntry): str =
    if len(entry.command) > 0:
        return "stdio"
    if len(entry.url) > 0:
        return "streamable_http"
    return "unknown"

fn mcpLiteAuthStatus(entry: McpLiteEntry): str =
    if len(entry.command) > 0:
        return "unsupported"
    if len(entry.url) == 0:
        return "unsupported"
    if len(entry.bearerTokenEnvVar) > 0:
        return "bearer_token"
    return "not_logged_in"

fn mcpLoadServersLiteFromConfig(): McpLiteEntry[] =
    var out: McpLiteEntry[] = []
    let path = codexConfigPath()
    if len(path) == 0 || ! os.fileExists(path):
        return out
    let content = os.readFile(path)
    if content == nil || len(content) == 0:
        return out
    let lines = splitLinesSimple(content)
    var sectionName = ""
    var sectionSub = ""
    for i in 0..<len(lines):
        let raw = mcpTrimCopy("" + lines[i])
        if len(raw) == 0 || hasPrefix(raw, "#"):
            continue
        if raw[0] == '[' && raw[len(raw) - 1] == ']':
            let section = mcpTrimCopy(mcpSliceCopy(raw, 1, len(raw) - 2))
            sectionName = ""
            sectionSub = ""
            if hasPrefix(section, "mcp_servers."):
                let prefixLen = len("mcp_servers.")
                var dot: int32 = -1
                for j in prefixLen..<len(section):
                    if section[j] == '.':
                        dot = j
                        break
                if dot > prefixLen:
                    sectionName = mcpTrimCopy(mcpSliceCopy(section, prefixLen, dot - 1))
                    if dot + 1 <= len(section) - 1:
                        sectionSub = normalizePolicy(mcpTrimCopy(mcpSliceCopy(section, dot + 1, len(section) - 1)))
                elif prefixLen <= len(section) - 1:
                    sectionName = mcpTrimCopy(mcpSliceCopy(section, prefixLen, len(section) - 1))
            continue
        if len(sectionName) == 0:
            continue
        let eq = findChar(raw, '=')
        if eq <= 0:
            continue
        let keyText = normalizePolicy(mcpTrimCopy(mcpSliceCopy(raw, 0, eq - 1)))
        let valueText = mcpTrimCopy(mcpSliceCopy(raw, eq + 1, len(raw) - 1))
        let idx = mcpLiteEnsureIndex(out, sectionName)
        var entry = out[idx]
        if len(sectionSub) > 0 && sectionSub != "env" && sectionSub != "http_headers" && sectionSub != "env_http_headers":
            continue
        if sectionSub == "env" || sectionSub == "http_headers" || sectionSub == "env_http_headers":
            out[idx] = entry
            continue
        if keyText == "command":
            entry.command = mcpParseStringValueSimple(valueText)
        elif keyText == "args":
            entry.argsRaw = valueText
        elif keyText == "cwd":
            entry.cwd = mcpParseStringValueSimple(valueText)
        elif keyText == "url":
            entry.url = mcpParseStringValueSimple(valueText)
        elif keyText == "bearer_token_env_var":
            entry.bearerTokenEnvVar = mcpParseStringValueSimple(valueText)
        elif keyText == "enabled":
            var enabled = true
            if mcpParseBoolValue(valueText, enabled):
                entry.enabled = enabled
        elif keyText == "disabled_reason":
            entry.disabledReason = mcpParseStringValueSimple(valueText)
        elif keyText == "enabled_tools":
            entry.enabledToolsRaw = valueText
        elif keyText == "disabled_tools":
            entry.disabledToolsRaw = valueText
        elif keyText == "startup_timeout_sec":
            var startupText = ""
            if mcpNormalizeNumberValue(valueText, startupText):
                entry.startupTimeoutSec = startupText
        elif keyText == "tool_timeout_sec":
            var toolText = ""
            if mcpNormalizeNumberValue(valueText, toolText):
                entry.toolTimeoutSec = toolText
        out[idx] = entry
    return out

fn mcpApplySimpleFieldValue(entryIn: McpServerEntry, keyText: str, valueText: str): McpServerEntry =
    var entry = entryIn
    let keyNorm = mcpCanonicalKey(keyText)
    if keyNorm == "command":
        entry.command = mcpParseStringValueSimple(valueText)
    elif keyNorm == "args":
        entry.args = mcpParseStringArraySimple(valueText)
    elif keyNorm == "env_vars":
        entry.envVars = mcpParseStringArraySimple(valueText)
    elif keyNorm == "cwd":
        entry.cwd = mcpParseStringValueSimple(valueText)
    elif keyNorm == "url":
        entry.url = mcpParseStringValueSimple(valueText)
    elif keyNorm == "bearer_token_env_var":
        entry.bearerTokenEnvVar = mcpParseStringValueSimple(valueText)
    elif keyNorm == "enabled":
        var enabled = false
        if mcpParseBoolValue(valueText, enabled):
            entry.enabled = enabled
    elif keyNorm == "disabled_reason":
        entry.disabledReason = mcpParseStringValueSimple(valueText)
    elif keyNorm == "enabled_tools":
        entry.enabledTools = mcpParseStringArraySimple(valueText)
        entry.hasEnabledTools = true
    elif keyNorm == "disabled_tools":
        entry.disabledTools = mcpParseStringArraySimple(valueText)
        entry.hasDisabledTools = true
    elif keyNorm == "startup_timeout_sec":
        var startupText = ""
        if mcpNormalizeNumberValue(valueText, startupText):
            entry.startupTimeoutSec = startupText
            entry.hasStartupTimeout = true
    elif keyNorm == "startup_timeout_ms":
        if ! entry.hasStartupTimeout:
            let ms = parseInt64Simple(trimLine(valueText), -1)
            if ms >= 0:
                let secs = mcpSecondsFromMillis(ms)
                if len(secs) > 0:
                    entry.startupTimeoutSec = secs
                    entry.hasStartupTimeout = true
    elif keyNorm == "tool_timeout_sec":
        var toolText = ""
        if mcpNormalizeNumberValue(valueText, toolText):
            entry.toolTimeoutSec = toolText
            entry.hasToolTimeout = true
    return entry

fn mcpLoadServersFromConfig(): McpServerEntry[] =
    var servers: McpServerEntry[] = []
    let path = codexConfigPath()
    if len(path) == 0 || ! os.fileExists(path):
        return servers
    let content = os.readFile(path)
    if content == nil || len(content) == 0:
        return servers
    let lines = splitLinesSimple(content)
    var sectionName = ""
    var sectionSub = ""
    for i in 0..<len(lines):
        let raw = mcpTrimCopy("" + lines[i])
        if len(raw) == 0 || hasPrefix(raw, "#"):
            continue
        if raw[0] == '[' && raw[len(raw) - 1] == ']':
            let section = mcpTrimCopy(mcpSliceCopy(raw, 1, len(raw) - 2))
            sectionName = ""
            sectionSub = ""
            if hasPrefix(section, "mcp_servers."):
                let prefixLen = len("mcp_servers.")
                var dot: int32 = -1
                for didx in prefixLen..<len(section):
                    if section[didx] == '.':
                        dot = didx
                        break
                if dot > prefixLen:
                    sectionName = mcpTrimCopy(mcpSliceCopy(section, prefixLen, dot - 1))
                    if dot + 1 <= len(section) - 1:
                        sectionSub = normalizePolicy(mcpTrimCopy(mcpSliceCopy(section, dot + 1, len(section) - 1)))
                elif prefixLen <= len(section) - 1:
                    sectionName = mcpTrimCopy(mcpSliceCopy(section, prefixLen, len(section) - 1))
            continue
        let eq = findChar(raw, '=')
        if eq <= 0:
            continue
        let keyText = mcpTrimCopy(mcpSliceCopy(raw, 0, eq - 1))
        let valueText = mcpTrimCopy(mcpSliceCopy(raw, eq + 1, len(raw) - 1))
        if len(keyText) == 0:
            continue
        if len(sectionName) > 0:
            let sidx = mcpEnsureServerIndexSimple(servers, sectionName)
            var entry = servers[sidx]
            if sectionSub == "env":
                mcpSetPair(entry.env, keyText, mcpParseStringValueSimple(valueText))
                entry.hasEnv = true
            elif sectionSub == "http_headers":
                mcpSetPair(entry.httpHeaders, keyText, mcpParseStringValueSimple(valueText))
                entry.hasHttpHeaders = true
            elif sectionSub == "env_http_headers":
                mcpSetPair(entry.envHttpHeaders, keyText, mcpParseStringValueSimple(valueText))
                entry.hasEnvHttpHeaders = true
            else:
                let keyNorm = normalizePolicy(keyText)
                if keyNorm == "command":
                    entry.command = mcpParseStringValueSimple(valueText)
                elif keyNorm == "args":
                    entry.args = mcpParseStringArraySimple(valueText)
                elif keyNorm == "env_vars":
                    entry.envVars = mcpParseStringArraySimple(valueText)
                elif keyNorm == "cwd":
                    entry.cwd = mcpParseStringValueSimple(valueText)
                elif keyNorm == "url":
                    entry.url = mcpParseStringValueSimple(valueText)
                elif keyNorm == "bearer_token_env_var":
                    entry.bearerTokenEnvVar = mcpParseStringValueSimple(valueText)
                elif keyNorm == "enabled":
                    var enabled = false
                    if mcpParseBoolValue(valueText, enabled):
                        entry.enabled = enabled
                elif keyNorm == "disabled_reason":
                    entry.disabledReason = mcpParseStringValueSimple(valueText)
                elif keyNorm == "enabled_tools":
                    entry.enabledTools = mcpParseStringArraySimple(valueText)
                    entry.hasEnabledTools = true
                elif keyNorm == "disabled_tools":
                    entry.disabledTools = mcpParseStringArraySimple(valueText)
                    entry.hasDisabledTools = true
                elif keyNorm == "startup_timeout_sec":
                    var startupText = ""
                    if mcpNormalizeNumberValue(valueText, startupText):
                        entry.startupTimeoutSec = startupText
                        entry.hasStartupTimeout = true
                elif keyNorm == "startup_timeout_ms":
                    if ! entry.hasStartupTimeout:
                        let ms = parseInt64Simple(mcpTrimCopy(valueText), -1)
                        if ms >= 0:
                            let secs = mcpSecondsFromMillis(ms)
                            if len(secs) > 0:
                                entry.startupTimeoutSec = secs
                                entry.hasStartupTimeout = true
                elif keyNorm == "tool_timeout_sec":
                    var toolText = ""
                    if mcpNormalizeNumberValue(valueText, toolText):
                        entry.toolTimeoutSec = toolText
                        entry.hasToolTimeout = true
            servers[sidx] = entry
            continue
    return servers

fn mcpFormatEnvDisplay(envPairs: McpStringPair[], envVars: str[]): str =
    var parts: str[] = []
    if len(envPairs) > 0:
        var sorted = envPairs
        mcpSortPairsByKey(sorted)
        for idx in 0..<len(sorted):
            add(parts, sorted[idx].key + "=*****")
    if len(envVars) > 0:
        for idx in 0..<len(envVars):
            add(parts, envVars[idx] + "=*****")
    if len(parts) == 0:
        return "-"
    var out = ""
    for idx in 0..<len(parts):
        if idx == 0:
            out = parts[idx]
        else:
            out = out + ", " + parts[idx]
    return out

fn mcpFormatHeadersDisplay(headers: McpStringPair[], maskValues: bool): str =
    if len(headers) == 0:
        return "-"
    var sorted = headers
    mcpSortPairsByKey(sorted)
    var out = ""
    for idx in 0..<len(sorted):
        var value: str = sorted[idx].value
        if maskValues:
            value = "*****"
        let part = sorted[idx].key + "=" + value
        if idx == 0:
            out = part
        else:
            out = out + ", " + part
    return out

fn mcpAuthDisplay(status: int32): str =
    if status == mcpAuthBearerToken:
        return "Bearer token"
    if status == mcpAuthOAuth:
        return "OAuth"
    if status == mcpAuthNotLoggedIn:
        return "Not logged in"
    return "Unsupported"

fn mcpAuthJson(status: int32): str =
    if status == mcpAuthBearerToken:
        return "bearer_token"
    if status == mcpAuthOAuth:
        return "oauth"
    if status == mcpAuthNotLoggedIn:
        return "not_logged_in"
    return "unsupported"

fn mcpHasOAuthTokens(name: str, url: str): bool =
    return mcpOauthHasTokens(name, url)

fn mcpDetermineAuthStatus(entry: McpServerEntry): int32 =
    if len(entry.command) > 0:
        return mcpAuthUnsupported
    if len(entry.url) == 0:
        return mcpAuthUnsupported
    if len(entry.bearerTokenEnvVar) > 0:
        return mcpAuthBearerToken
    if mcpHasOAuthTokens(entry.name, entry.url):
        return mcpAuthOAuth
    return mcpAuthNotLoggedIn

fn mcpFormatStatus(entry: McpServerEntry): str =
    if entry.enabled:
        return "enabled"
    if len(entry.disabledReason) > 0:
        return "disabled: " + entry.disabledReason
    return "disabled"

fn mcpHasTransport(entry: McpServerEntry): bool =
    return len(entry.command) > 0 || len(entry.url) > 0

fn mcpHeadersFromEntry(entry: McpServerEntry): str[] =
    var headers: str[] = []
    if entry.hasHttpHeaders:
        for idx in 0..<len(entry.httpHeaders):
            let pair = entry.httpHeaders[idx]
            add(headers, pair.key + ": " + pair.value)
    if entry.hasEnvHttpHeaders:
        for idx in 0..<len(entry.envHttpHeaders):
            let pair = entry.envHttpHeaders[idx]
            let envVal = os.getEnv(pair.value)
            if len(envVal) > 0:
                add(headers, pair.key + ": " + envVal)
    return headers

fn mcpJsonArrayFromStrings(items: str[]): str =
    var jsonItems: str[] = []
    for idx in 0..<items.len:
        add(jsonItems, jstrString(items[idx]))
    return jstrArray(jsonItems)

fn mcpJsonObjectFromPairs(pairs: McpStringPair[]): str =
    var items: str[] = []
    for idx in 0..<pairs.len:
        add(items, jstrPair(pairs[idx].key, jstrString(pairs[idx].value)))
    return jstrObject(items)

fn mcpJsonNumberOrString(rawValue: str): str =
    let trimmed = trimLine(rawValue)
    if mcpIsNumericLiteral(trimmed):
        return trimmed
    return jstrString(rawValue)

fn padRight(text: str, width: int32): str =
    if len(text) >= width:
        return text
    return text + repeatChar(' ', width - len(text))

fn joinComma(items: str[]): str =
    var out = ""
    for idx in 0..<items.len:
        if idx == 0:
            out = items[idx]
        else:
            out = out + ", " + items[idx]
    return out

fn mcpTransportJson(entry: McpServerEntry): str =
    var pairs: str[] = []
    if len(entry.command) > 0:
        add(pairs, jstrPair("type", jstrString("stdio")))
        add(pairs, jstrPair("command", jstrString(entry.command)))
        add(pairs, jstrPair("args", mcpJsonArrayFromStrings(entry.args)))
        let envJson = if entry.hasEnv: mcpJsonObjectFromPairs(entry.env) else: jstrNull()
        add(pairs, jstrPair("env", envJson))
        add(pairs, jstrPair("env_vars", mcpJsonArrayFromStrings(entry.envVars)))
        let cwdJson = if len(entry.cwd) > 0: jstrString(entry.cwd) else: jstrNull()
        add(pairs, jstrPair("cwd", cwdJson))
        return jstrObject(pairs)
    if len(entry.url) > 0:
        add(pairs, jstrPair("type", jstrString("streamable_http")))
        add(pairs, jstrPair("url", jstrString(entry.url)))
        let bearerJson = if len(entry.bearerTokenEnvVar) > 0: jstrString(entry.bearerTokenEnvVar) else: jstrNull()
        add(pairs, jstrPair("bearer_token_env_var", bearerJson))
        let headersJson = if entry.hasHttpHeaders: mcpJsonObjectFromPairs(entry.httpHeaders) else: jstrNull()
        add(pairs, jstrPair("http_headers", headersJson))
        let envHeadersJson = if entry.hasEnvHttpHeaders: mcpJsonObjectFromPairs(entry.envHttpHeaders) else: jstrNull()
        add(pairs, jstrPair("env_http_headers", envHeadersJson))
        return jstrObject(pairs)
    return jstrNull()

fn mcpFormatTomlString(value: str): str =
    return "\"" + escapeConfigValue(value) + "\""

fn mcpFormatTomlStringArray(items: str[]): str =
    var out = "["
    for idx in 0..<items.len:
        if idx > 0:
            out = out + ", "
        out = out + mcpFormatTomlString(items[idx])
    out = out + "]"
    return out

fn mcpBuildStdioConfigLines(name: str, command: str, args: str[], envPairs: McpStringPair[]): str[] =
    var lines: str[] = []
    add(lines, "[mcp_servers." + name + "]")
    add(lines, "command = " + mcpFormatTomlString(command))
    if len(args) > 0:
        add(lines, "args = " + mcpFormatTomlStringArray(args))
    if len(envPairs) > 0:
        add(lines, "")
        add(lines, "[mcp_servers." + name + ".env]")
        var sorted = envPairs
        mcpSortPairsByKey(sorted)
        for idx in 0..<len(sorted):
            add(lines, sorted[idx].key + " = " + mcpFormatTomlString(sorted[idx].value))
    return lines

fn mcpBuildHttpConfigLines(name: str, url: str, bearerTokenEnvVar: str): str[] =
    var lines: str[] = []
    add(lines, "[mcp_servers." + name + "]")
    add(lines, "url = " + mcpFormatTomlString(url))
    if len(bearerTokenEnvVar) > 0:
        add(lines, "bearer_token_env_var = " + mcpFormatTomlString(bearerTokenEnvVar))
    return lines

fn mcpJoinLines(lines: str[]): str =
    var out = ""
    for idx in 0..<len(lines):
        if idx == 0:
            out = lines[idx]
        else:
            out = out + "\n" + lines[idx]
    if len(out) > 0:
        out = out + "\n"
    return out

fn mcpRemoveServerFromLines(lines: str[], name: str, removed: var bool): str[] =
    removed = false
    var out: str[] = []
    var section = ""
    var skipPrefix = ""
    for idx in 0..<len(lines):
        let rawLine = lines[idx]
        let noComment = stripInlineComment(rawLine)
        let trimmed = trimLine(noComment)
        if len(trimmed) > 0 && trimmed[0] == '[' && trimmed[len(trimmed) - 1] == ']':
            section = trimLine(__cheng_slice_string(trimmed, 1, len(trimmed) - 2, false))
            if len(skipPrefix) > 0:
                if hasPrefix(section, skipPrefix):
                    removed = true
                    continue
                skipPrefix = ""
            let prefix = "mcp_servers." + name
            if hasPrefix(section, prefix):
                skipPrefix = prefix
                removed = true
                continue
            add(out, rawLine)
            continue
        if len(skipPrefix) > 0:
            continue
        if len(trimmed) == 0 || trimmed[0] == '#':
            add(out, rawLine)
            continue
        let eq = findChar(trimmed, '=')
        if eq > 0:
            let keyText = trimLine(__cheng_slice_string(trimmed, 0, eq - 1, false))
            if section == "mcp_servers":
                if keyText == name || hasPrefix(keyText, name + "."):
                    removed = true
                    continue
            if hasPrefix(keyText, "mcp_servers." + name):
                removed = true
                continue
        add(out, rawLine)
    return out

fn mcpSectionNameFromHeaderLine(line: str): str =
    let trimmed = mcpStripInlineCommentCopy(line)
    if len(trimmed) < 2:
        return ""
    if ! hasPrefix("" + trimmed, "["):
        return ""
    var lastCh: char = '\0'
    for idx in 0..<len(trimmed):
        lastCh = trimmed[idx]
    if lastCh != ']':
        return ""
    var section = ""
    let stop = len(trimmed) - 1
    for sidx in 1..<stop:
        let ch = trimmed[sidx]
        section = section + $ ch
    return mcpTrimCopy(section)

fn mcpIsTargetSection(section: str, name: str): bool =
    let prefix = "mcp_servers." + name
    if section == prefix:
        return true
    if hasPrefix("" + section, prefix + "."):
        return true
    return false

fn mcpRemoveServerFromLinesSafe(lines: str[], name: str): str[] =
    var out: str[] = []
    var skipSection = false
    for idx in 0..<len(lines):
        let rawLine = "" + lines[idx]
        let section = mcpSectionNameFromHeaderLine(rawLine)
        if len(section) > 0:
            if mcpIsTargetSection(section, name):
                skipSection = true
                continue
            skipSection = false
            add(out, rawLine)
            continue
        if skipSection:
            continue
        add(out, rawLine)
    return out

fn mcpWriteConfigLines(lines: str[]): bool =
    let home = codexHomeDir()
    if len(home) == 0:
        return false
    if ! os.dirExists(home):
        os.createDir(home)
    let path = codexConfigPath()
    os.writeFile(path, mcpJoinLines(lines))
    return true

fn mcpParseEnvPair(raw: str, outKey: var str, outValue: var str): bool =
    let eq = findChar(raw, '=')
    if eq <= 0:
        return false
    let keyText = trimLine(__cheng_slice_string(raw, 0, eq - 1, false))
    var valText: str = ""
    if eq + 1 <= len(raw) - 1:
        valText = __cheng_slice_string(raw, eq + 1, len(raw) - 1, false)
    if len(keyText) == 0:
        return false
    outKey = keyText
    outValue = valText
    return true

fn mcpValidServerName(name: str): bool =
    if len(name) == 0:
        return false
    for idx in 0..<len(name):
        let ch = name[idx]
        if (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') || (ch >= '0' && ch <= '9') || ch == '-' || ch == '_':
            continue
        return false
    return true

fn mcpJoinSpace(items: str[]): str =
    var out = ""
    for idx in 0..<items.len:
        if idx == 0:
            out = items[idx]
        else:
            out = out + " " + items[idx]
    return out

fn mcpToolListDisplay(hasTools: bool, tools: str[]): str =
    if ! hasTools:
        return "-"
    if len(tools) == 0:
        return "[]"
    return joinComma(tools)

fn mcpToolListJson(hasTools: bool, tools: str[]): str =
    if ! hasTools:
        return jstrNull()
    return mcpJsonArrayFromStrings(tools)

fn mcpTimeoutJson(hasTimeout: bool, raw: str): str =
    if ! hasTimeout:
        return jstrNull()
    return mcpJsonNumberOrString(raw)

fn mcpServerJson(entry: McpServerEntry, includeToolFilters: bool, includeAuthStatus: bool): str =
    var fields: str[] = []
    let authStatus = mcpDetermineAuthStatus(entry)
    add(fields, jstrPair("name", jstrString(entry.name)))
    add(fields, jstrPair("enabled", jstrBool(entry.enabled)))
    let disabledReasonJson = if len(entry.disabledReason) > 0: jstrString(entry.disabledReason) else: jstrNull()
    add(fields, jstrPair("disabled_reason", disabledReasonJson))
    add(fields, jstrPair("transport", mcpTransportJson(entry)))
    if includeToolFilters:
        add(fields, jstrPair("enabled_tools", mcpToolListJson(entry.hasEnabledTools, entry.enabledTools)))
        add(fields, jstrPair("disabled_tools", mcpToolListJson(entry.hasDisabledTools, entry.disabledTools)))
    add(fields, jstrPair("startup_timeout_sec", mcpTimeoutJson(entry.hasStartupTimeout, entry.startupTimeoutSec)))
    add(fields, jstrPair("tool_timeout_sec", mcpTimeoutJson(entry.hasToolTimeout, entry.toolTimeoutSec)))
    if includeAuthStatus:
        add(fields, jstrPair("auth_status", jstrString(mcpAuthJson(authStatus))))
    return jstrObject(fields)

fn mcpPrintStdioRows(rows: McpStdioRow[]) =
    if len(rows) == 0:
        return
    printLine("Name  Command  Args  Env  Cwd  Status  Auth")
    for idx in 0..<len(rows):
        let row = rows[idx]
        # Build incrementally to avoid deep temporary chains.
        var line: str = row.name
        line = line + "  "
        line = line + row.command
        line = line + "  "
        line = line + row.args
        line = line + "  "
        line = line + row.env
        line = line + "  "
        line = line + row.cwd
        line = line + "  "
        line = line + row.status
        line = line + "  "
        line = line + row.auth
        printLine(line)

fn mcpPrintHttpRows(rows: McpHttpRow[]) =
    if len(rows) == 0:
        return
    printLine("Name  URL  Bearer Token Var  Status  Auth")
    for idx in 0..<len(rows):
        let row = rows[idx]
        # Build incrementally to avoid deep temporary chains.
        var line: str = row.name
        line = line + "  "
        line = line + row.url
        line = line + "  "
        line = line + row.bearerTokenVar
        line = line + "  "
        line = line + row.status
        line = line + "  "
        line = line + row.auth
        printLine(line)

fn runMcpList(args: str[], start: int32): int32 =
    var json = false
    for i in start..<len(args):
        let arg = argAt(args, i)
        if arg == "--help" || arg == "-h":
            printLine("usage: codex mcp list [--json]")
            return 0
        if arg == "--json":
            json = true
        else:
            printErr("unknown option: " + arg)
            return 2
    var servers = mcpLoadServersLiteFromConfig()
    mcpLiteSortByName(servers)
    if json:
        var entries: str[] = []
        for idx in 0..<servers.len:
            let entry = servers[idx]
            let transportType = mcpLiteTransportType(entry)
            var fields: str[] = []
            var transportFields: str[] = []
            add(transportFields, jstrPair("type", jstrString(transportType)))
            if len(entry.command) > 0:
                add(transportFields, jstrPair("command", jstrString(entry.command)))
            elif len(entry.url) > 0:
                add(transportFields, jstrPair("url", jstrString(entry.url)))
            add(fields, jstrPair("name", jstrString(entry.name)))
            add(fields, jstrPair("enabled", jstrBool(entry.enabled)))
            add(fields, jstrPair("disabled_reason", if len(entry.disabledReason) > 0: jstrString(entry.disabledReason) else: jstrNull()))
            add(fields, jstrPair("transport", jstrObject(transportFields)))
            add(fields, jstrPair("auth_status", jstrString(mcpLiteAuthStatus(entry))))
            add(entries, jstrObject(fields))
        printLine(jstrArray(entries))
        return 0
    if servers.len == 0:
        printLine("No MCP servers configured yet. Try `codex mcp add my-tool -- my-command`.")
        return 0
    for idx in 0..<servers.len:
        let entry = servers[idx]
        printLine(entry.name)
    return 0

fn runMcpGet(args: str[], start: int32): int32 =
    var json = false
    var name = ""
    for i in start..<len(args):
        let arg = argAt(args, i)
        if arg == "--help" || arg == "-h":
            printLine("usage: codex mcp get <name> [--json]")
            return 0
        if arg == "--json":
            json = true
        elif len(name) == 0:
            name = arg
        else:
            printErr("unknown option: " + arg)
            return 2
    if len(name) == 0:
        printErr("missing mcp server name")
        return 2
    var servers = mcpLoadServersLiteFromConfig()
    let idx = mcpLiteFindIndex(servers, name)
    if idx < 0:
        printErr("No MCP server named '" + name + "' found.")
        return 2
    let entry = servers[idx]
    if json:
        let transportType = mcpLiteTransportType(entry)
        var fields: str[] = []
        var transportFields: str[] = []
        add(transportFields, jstrPair("type", jstrString(transportType)))
        if len(entry.command) > 0:
            add(transportFields, jstrPair("command", jstrString(entry.command)))
            add(transportFields, jstrPair("args", mcpJsonArrayFromStrings(mcpParseStringArraySimple(entry.argsRaw))))
            add(transportFields, jstrPair("cwd", if len(entry.cwd) > 0: jstrString(entry.cwd) else: jstrNull()))
        elif len(entry.url) > 0:
            add(transportFields, jstrPair("url", jstrString(entry.url)))
            add(transportFields, jstrPair("bearer_token_env_var", if len(entry.bearerTokenEnvVar) > 0: jstrString(entry.bearerTokenEnvVar) else: jstrNull()))
        add(fields, jstrPair("name", jstrString(entry.name)))
        add(fields, jstrPair("enabled", jstrBool(entry.enabled)))
        add(fields, jstrPair("disabled_reason", if len(entry.disabledReason) > 0: jstrString(entry.disabledReason) else: jstrNull()))
        add(fields, jstrPair("transport", jstrObject(transportFields)))
        let enabledTools = mcpParseStringArraySimple(entry.enabledToolsRaw)
        let disabledTools = mcpParseStringArraySimple(entry.disabledToolsRaw)
        add(fields, jstrPair("enabled_tools", if len(entry.enabledToolsRaw) > 0: mcpJsonArrayFromStrings(enabledTools) else: jstrNull()))
        add(fields, jstrPair("disabled_tools", if len(entry.disabledToolsRaw) > 0: mcpJsonArrayFromStrings(disabledTools) else: jstrNull()))
        add(fields, jstrPair("startup_timeout_sec", if len(entry.startupTimeoutSec) > 0: mcpJsonNumberOrString(entry.startupTimeoutSec) else: jstrNull()))
        add(fields, jstrPair("tool_timeout_sec", if len(entry.toolTimeoutSec) > 0: mcpJsonNumberOrString(entry.toolTimeoutSec) else: jstrNull()))
        printLine(jstrObject(fields))
        return 0
    if ! entry.enabled:
        if len(entry.disabledReason) > 0:
            var line: str = entry.name
            line = line + " (disabled: "
            line = line + entry.disabledReason
            line = line + ")"
            printLine(line)
        else:
            printLine(entry.name + " (disabled)")
        return 0
    printLine(entry.name)
    return 0

fn runMcpAdd(args: str[], start: int32): int32 =
    if start >= len(args):
        printLine("usage: codex mcp add [OPTIONS] <NAME> (--url <URL> | -- <COMMAND>...)")
        return 2
    let name = "" + argAt(args, start)
    if name == "--help" || name == "-h":
        printLine("usage: codex mcp add [OPTIONS] <NAME> (--url <URL> | -- <COMMAND>...)")
        printLine("options:")
        printLine("  --env KEY=VALUE              set env var (stdio only)")
        printLine("  --url URL                    streamable HTTP server URL")
        printLine("  --bearer-token-env-var VAR   bearer token env var (http only)")
        return 0
    if ! mcpValidServerName(name):
        printErr("invalid server name '" + name + "' (use letters, numbers, '-', '_')")
        return 2
    var url = ""
    var bearerTokenEnvVar = ""
    var commandParts: str[] = []
    var envPairs: McpStringPair[] = []
    var skipUntil: int32 = start
    for i in start + 1..<len(args):
        if i <= skipUntil:
            continue
        let arg = argAt(args, i)
        if arg == "--help" || arg == "-h":
            printLine("usage: codex mcp add [OPTIONS] <NAME> (--url <URL> | -- <COMMAND>...)")
            return 0
        if arg == "--":
            for j in i + 1..<len(args):
                add(commandParts, "" + argAt(args, j))
            break
        if arg == "--url" && i + 1 < len(args):
            url = "" + argAt(args, i + 1)
            skipUntil = i + 1
        elif hasPrefix(arg, "--url:"):
            url = "" + dropPrefix(arg, "--url:")
        elif arg == "--bearer-token-env-var" && i + 1 < len(args):
            bearerTokenEnvVar = "" + argAt(args, i + 1)
            skipUntil = i + 1
        elif hasPrefix(arg, "--bearer-token-env-var:"):
            bearerTokenEnvVar = "" + dropPrefix(arg, "--bearer-token-env-var:")
        elif arg == "--env" && i + 1 < len(args):
            var key = ""
            var val = ""
            if ! mcpParseEnvPair(argAt(args, i + 1), key, val):
                printErr("environment entries must be in KEY=VALUE form")
                return 2
            mcpSetPair(envPairs, key, val)
            skipUntil = i + 1
        elif hasPrefix(arg, "--env:"):
            var key = ""
            var val = ""
            if ! mcpParseEnvPair(dropPrefix(arg, "--env:"), key, val):
                printErr("environment entries must be in KEY=VALUE form")
                return 2
            mcpSetPair(envPairs, key, val)
        elif len(commandParts) == 0 && len(url) == 0 && ! hasPrefix(arg, "-"):
            for j in i..<len(args):
                add(commandParts, "" + argAt(args, j))
            break
        else:
            printErr("unknown option: " + arg)
            return 2
    if len(url) > 0 && len(commandParts) > 0:
        printErr("exactly one of --url or -- <command> must be provided")
        return 2
    if len(url) == 0 && len(commandParts) == 0:
        printErr("command is required")
        return 2
    if len(url) > 0 && len(envPairs) > 0:
        printErr("--env is only supported with stdio servers")
        return 2
    if len(commandParts) > 0 && len(bearerTokenEnvVar) > 0:
        printErr("--bearer-token-env-var is only supported with streamable_http servers")
        return 2
    let path = codexConfigPath()
    var lines: str[] = []
    if len(path) > 0 && os.fileExists(path):
        let content = os.readFile(path)
        if len(content) > 0:
            lines = splitLinesSimple(content)
    var removed = false
    lines = mcpRemoveServerFromLines(lines, name, removed)
    if len(lines) > 0:
        if len(trimLine(lines[(len(lines) - 1)])) > 0:
            add(lines, "")
    var blockLines: str[] = []
    if len(url) > 0:
        blockLines = mcpBuildHttpConfigLines(name, url, bearerTokenEnvVar)
    else:
        let command = "" + commandParts[0]
        var argsList: str[] = []
        for idx in 1..<len(commandParts):
            add(argsList, "" + commandParts[idx])
        blockLines = mcpBuildStdioConfigLines(name, command, argsList, envPairs)
    for bidx in 0..<len(blockLines):
        add(lines, blockLines[bidx])
    if ! mcpWriteConfigLines(lines):
        printErr("failed to write config")
        return 1
    printLine("Added global MCP server '" + name + "'.")
    if len(url) > 0 && len(bearerTokenEnvVar) == 0:
        printLine("MCP server may or may not require login. Run `codex mcp login " + name + "` to login.")
    return 0

fn runMcpRemove(args: str[], start: int32): int32 =
    if start >= len(args):
        printLine("usage: codex mcp remove <name>")
        return 2
    let name = argAt(args, start)
    if name == "--help" || name == "-h":
        printLine("usage: codex mcp remove <name>")
        return 0
    if ! mcpValidServerName(name):
        printErr("invalid server name '" + name + "' (use letters, numbers, '-', '_')")
        return 2
    let path = codexConfigPath()
    if len(path) == 0 || ! os.fileExists(path):
        printLine("No MCP server named '" + name + "' found.")
        return 0
    let content = os.readFile(path)
    var lines: str[] = []
    if len(content) > 0:
        lines = splitLinesSimple(content)
    let originalLen = len(lines)
    lines = mcpRemoveServerFromLinesSafe(lines, name)
    let removed = len(lines) < originalLen
    if removed:
        if ! mcpWriteConfigLines(lines):
            printErr("failed to write config")
            return 1
        printLine("Removed global MCP server '" + name + "'.")
    else:
        printLine("No MCP server named '" + name + "' found.")
    return 0

fn mcpSplitScopesCsv(raw: str): str[] =
    var out: str[] = []
    let trimmed = trimLine(raw)
    if len(trimmed) == 0:
        return out
    var start: int32 = 0
    for i in 0..len(trimmed):
        if i == len(trimmed) || trimmed[i] == ',':
            if i > start:
                let scope = trimLine(__cheng_slice_string(trimmed, start, i - 1, false))
                if len(scope) > 0:
                    add(out, scope)
            start = i + 1
    return out

fn mcpAppendScopes(scopes: var str[], raw: str) =
    let parts = mcpSplitScopesCsv(raw)
    for i in 0..<len(parts):
        add(scopes, parts[i])

fn runMcpLogin(args: str[], start: int32): int32 =
    if start >= len(args):
        printLine("usage: codex mcp login <name> [--scopes SCOPE,SCOPE]")
        return 2
    var name = ""
    var scopes: str[] = []
    var skipUntil: int32 = start - 1
    for i in start..<len(args):
        if i <= skipUntil:
            continue
        let arg = argAt(args, i)
        if arg == "--help" || arg == "-h":
            printLine("usage: codex mcp login <name> [--scopes SCOPE,SCOPE]")
            return 0
        if arg == "--scopes" && i + 1 < len(args):
            mcpAppendScopes(scopes, argAt(args, i + 1))
            skipUntil = i + 1
        elif hasPrefix(arg, "--scopes:"):
            mcpAppendScopes(scopes, dropPrefix(arg, "--scopes:"))
        elif len(name) == 0:
            name = arg
        else:
            printErr("unknown option: " + arg)
            return 2
    if len(name) == 0:
        printErr("missing mcp server name")
        return 2
    let servers = mcpLoadServersFromConfig()
    let idx = mcpFindServerIndex(servers, name)
    if idx < 0:
        printErr("No MCP server named '" + name + "' found in configuration.")
        return 2
    let entry = servers[idx]
    if len(entry.url) == 0:
        printErr("OAuth login is only supported for streamable HTTP servers.")
        return 2
    let headers = mcpHeadersFromEntry(entry)
    var authUrl = ""
    var err = ""
    if ! mcpOauthLogin(name, entry.url, headers, scopes, true, true, authUrl, err):
        if len(err) == 0:
            err = "OAuth login failed"
        printErr(err)
        return 1
    printLine("Successfully logged in to MCP server '" + name + "'.")
    return 0

fn runMcpLogout(args: str[], start: int32): int32 =
    if start >= len(args):
        printLine("usage: codex mcp logout <name>")
        return 2
    let name = argAt(args, start)
    if name == "--help" || name == "-h":
        printLine("usage: codex mcp logout <name>")
        return 0
    let servers = mcpLoadServersFromConfig()
    let idx = mcpFindServerIndex(servers, name)
    if idx < 0:
        printErr("No MCP server named '" + name + "' found.")
        return 2
    let entry = servers[idx]
    if len(entry.url) == 0:
        printErr("OAuth logout is only supported for streamable HTTP servers.")
        return 2
    var removed = false
    if ! mcpOauthDeleteTokens(name, entry.url, removed):
        printErr("failed to delete OAuth credentials")
        return 1
    if removed:
        printLine("Removed OAuth credentials for '" + name + "'.")
    else:
        printLine("No OAuth credentials stored for '" + name + "'.")
    return 0

fn runMcpCommand(args: str[], start: int32): int32 =
    if start >= len(args):
        # `<COMMAND>` is required in codex-rs; print help-like output and exit 2.
        printLine("[experimental] Run Codex as an MCP server and manage MCP servers")
        printLine("")
        printLine("Usage: codex mcp [OPTIONS] <COMMAND>")
        printLine("")
        printLine("Commands:")
        printLine("  list    ")
        printLine("  get     ")
        printLine("  add     ")
        printLine("  remove  ")
        printLine("  login   ")
        printLine("  logout  ")
        printLine("  help    Print this message or the help of the given subcommand(s)")
        printLine("")
        printLine("Options:")
        printLine("  -c, --config <key=value>  Override a configuration value that would otherwise be loaded from")
        printLine("                            `~/.codex/config.toml`. Use a dotted path (`foo.bar.baz`) to override")
        printLine("                            nested values. The `value` portion is parsed as TOML. If it fails to")
        printLine("                            parse as TOML, the raw string is used as a literal")
        printLine("      --enable <FEATURE>    Enable a feature (repeatable). Equivalent to `-c features.<name>=true`")
        printLine("      --disable <FEATURE>   Disable a feature (repeatable). Equivalent to `-c features.<name>=false`")
        printLine("  -h, --help                Print help (see more with '--help')")
        return 2
    let cmd = argAt(args, start)
    if cmd == "--help" || cmd == "-h":
        printLine("[experimental] Run Codex as an MCP server and manage MCP servers")
        printLine("")
        printLine("Usage: codex mcp [OPTIONS] <COMMAND>")
        printLine("")
        printLine("Commands:")
        printLine("  list    ")
        printLine("  get     ")
        printLine("  add     ")
        printLine("  remove  ")
        printLine("  login   ")
        printLine("  logout  ")
        printLine("  help    Print this message or the help of the given subcommand(s)")
        printLine("")
        printLine("Options:")
        printConfigFlagHelp()
        printEnableFlagHelp()
        printDisableFlagHelp()
        printLine("  -h, --help")
        printLine("          Print help (see a summary with '-h')")
        return 0
    if cmd == "list":
        return runMcpList(args, start + 1)
    if cmd == "get":
        return runMcpGet(args, start + 1)
    if cmd == "add":
        return runMcpAdd(args, start + 1)
    if cmd == "remove":
        return runMcpRemove(args, start + 1)
    if cmd == "login":
        return runMcpLogin(args, start + 1)
    if cmd == "logout":
        return runMcpLogout(args, start + 1)
    printErr("unknown mcp command")
    return 2
