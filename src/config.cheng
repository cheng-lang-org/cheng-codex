# Config helpers for codex-cheng

import std/os
import std/strings
import seqs
import cheng/codex/common
import system
fn isSpace(ch: char): bool =
    ch == ' ' || ch == '\t' || ch == '\r' || ch == '\n'

fn trimLine(text: str): str =
    if text == nil:
        return ""
    var start: int32 = 0
    var stop: int32 = len(text) - 1
    for idx in 0..<len(text):
        if isSpace(text[idx]):
            start = idx + 1
            continue
        break
    for rev in 0..<len(text):
        let idx = len(text) - rev - 1
        if idx < start:
            break
        if isSpace(text[idx]):
            stop = idx - 1
            continue
        break
    if start > stop:
        return ""
    # Return an owned string: slice views can dangle once the source buffer drops.
    return "" + __cheng_slice_string(text, start, stop, false)

fn splitLinesSimple(text: str): str[] =
    var out: str[] = []
    var start: int32 = 0
    for i in 0..<len(text):
        if text[i] == '\n':
            var endIdx: int32 = i - 1
            if endIdx >= start && text[endIdx] == '\r':
                endIdx = endIdx - 1
            if endIdx >= start:
                add(out, "" + __cheng_slice_string(text, start, endIdx, false))
            else:
                add(out, "")
            start = i + 1
    if start <= len(text) - 1:
        add(out, "" + __cheng_slice_string(text, start, len(text) - 1, false))
    elif start == len(text):
        add(out, "")
    return out

fn configEmptyStrList(): str[] =
    var out: str[]
    return out

var configOverrideKeys: str[] = configEmptyStrList()
var configOverrideValues: str[] = configEmptyStrList()

fn clearConfigOverrides() =
    configOverrideKeys = []
    configOverrideValues = []

fn addConfigOverride(key: str, value: str) =
    if len(key) == 0:
        return
    add(configOverrideKeys, key)
    add(configOverrideValues, value)

fn findConfigOverrideIndex(key: str): int32 =
    for idx in 0..<len(configOverrideKeys):
        if configOverrideKeys[idx] == key:
            return idx
    return -1

fn setConfigOverrides(overrides: str[]) =
    clearConfigOverrides()
    for idx in 0..<len(overrides):
        let raw = overrides[idx]
        let eq = findChar(raw, '=')
        if eq > 0:
            let keyText = trimLine(__cheng_slice_string(raw, 0, eq - 1, false))
            let valueText = trimLine(__cheng_slice_string(raw, eq + 1, len(raw) - 1, false))
            # codex-rs parses the `value` portion as TOML. We don't implement a full TOML
            # parser here, but we must at least unquote/escape string literals so
            # `-c model="o3"` behaves like `model=o3`.
            addConfigOverride(keyText, unescapeConfigValue(valueText))

fn configOverrideValue(key: str, outValue: var str): bool =
    if len(key) == 0:
        return false
    for rev in 0..<len(configOverrideKeys):
        let idx: int32 = len(configOverrideKeys) - 1 - rev
        if configOverrideKeys[idx] == key:
            outValue = configOverrideValues[idx]
            return true
    return false

fn findChar(text: str, needle: char): int32 =
    for i in 0..<len(text):
        if text[i] == needle:
            return i
    return -1

fn unescapeConfigValue(raw: str): str =
    let trimmed = trimLine(raw)
    if len(trimmed) < 2:
        return trimmed
    if trimmed[0] != '"' || trimmed[len(trimmed) - 1] != '"':
        return trimmed
    var outVal = ""
    let endIdx: int32 = len(trimmed) - 1
    var skipUntil: int32 = 0
    for i in 1..<endIdx:
        if i <= skipUntil:
            continue
        let ch = trimmed[i]
        if ch == '\\' && i + 1 < endIdx:
            let next = trimmed[i + 1]
            if next == 'n':
                outVal = outVal + "\n"
            elif next == 'r':
                outVal = outVal + "\r"
            elif next == 't':
                outVal = outVal + "\t"
            else:
                outVal = outVal + $ next
            skipUntil = i + 1
            continue
        outVal = outVal + $ ch
    return outVal

fn escapeConfigValue(value: str): str =
    if value == nil:
        return ""
    var outVal = ""
    for i in 0..<len(value):
        let ch = value[i]
        if ch == '\\':
            outVal = outVal + "\\\\"
        elif ch == '"':
            outVal = outVal + "\\\""
        elif ch == '\n':
            outVal = outVal + "\\n"
        elif ch == '\r':
            outVal = outVal + "\\r"
        elif ch == '\t':
            outVal = outVal + "\\t"
        else:
            outVal = outVal + $ ch
    return outVal

fn codexHomeDir(): str =
    let envHome = os.getEnv("CODEX_HOME")
    if len(envHome) > 0:
        return envHome
    let home = os.getEnv("HOME")
    if len(home) > 0:
        return os.joinPath(home, ".codex")
    return os.joinPath(currentDirSafe(), ".codex")

fn codexThreadsDir(): str =
    return os.joinPath(codexHomeDir(), "threads")

fn codexConfigPath(): str =
    return os.joinPath(codexHomeDir(), "config.toml")

fn codexAuthJsonPath(): str =
    return os.joinPath(codexHomeDir(), "auth.json")

fn writeAuthJsonApiKey(token: str): bool =
    if len(token) == 0:
        return false
    let home = codexHomeDir()
    if len(home) == 0:
        return false
    if ! os.dirExists(home):
        os.createDir(home)
    let path = codexAuthJsonPath()
    var lines = "{\n"
    lines = lines + "  \"auth_mode\": \"api_key\",\n"
    lines = lines + "  \"OPENAI_API_KEY\": " + jstrString(token) + "\n"
    lines = lines + "}\n"
    let content = lines
    os.writeFile(path, content)
    return true

fn clearAuthJson(): bool =
    let path = codexAuthJsonPath()
    if len(path) == 0:
        return false
    if os.fileExists(path):
        os.removeFile(path)
    return true

fn readConfigValueRaw(key: str, outValue: var str): bool =
    outValue = ""
    if len(key) == 0:
        return false
    let path = codexConfigPath()
    if len(path) == 0 || ! os.fileExists(path):
        return false
    let content = os.readFile(path)
    if len(content) == 0:
        return false
    let lines = splitLinesSimple(content)
    for idx in 0..<len(lines):
        let line = trimLine(lines[idx])
        if len(line) == 0 || line[0] == '#':
            continue
        let eq = findChar(line, '=')
        if eq <= 0:
            continue
        let keyText = trimLine(__cheng_slice_string(line, 0, eq - 1, false))
        if keyText == key:
            if eq + 1 <= len(line) - 1:
                let valueText = trimLine(__cheng_slice_string(line, eq + 1, len(line) - 1, false))
                outValue = unescapeConfigValue(valueText)
            return true
    return false

fn activeConfigProfile(outProfile: var str): bool =
    outProfile = ""
    var overrideProfile = ""
    if configOverrideValue("config_profile", overrideProfile):
        outProfile = overrideProfile
        return len(overrideProfile) > 0
    if configOverrideValue("profile", overrideProfile):
        outProfile = overrideProfile
        return len(overrideProfile) > 0
    var fileProfile = ""
    if readConfigValueRaw("profile", fileProfile):
        outProfile = fileProfile
        return len(fileProfile) > 0
    return false

fn readConfigValue(key: str): str =
    if len(key) == 0:
        return ""
    var overrideValue = ""
    if configOverrideValue(key, overrideValue):
        return overrideValue
    var profile = ""
    if len(key) > 0 && ! hasPrefix(key, "profiles.") && key != "profile":
        if activeConfigProfile(profile) && len(profile) > 0:
            var profileValue = ""
            # Build incrementally to avoid deep temporary chains.
            var scopedKey: str = "profiles."
            scopedKey = scopedKey + profile
            scopedKey = scopedKey + "."
            scopedKey = scopedKey + key
            if readConfigValueRaw(scopedKey, profileValue):
                return profileValue
    var rawValue = ""
    if readConfigValueRaw(key, rawValue):
        return rawValue
    return ""

fn writeConfigValue(key: str, value: str): bool =
    if len(key) == 0:
        return false
    let home = codexHomeDir()
    if len(home) == 0:
        return false
    if ! os.dirExists(home):
        os.createDir(home)
    let path = codexConfigPath()
    var lines: str[] = []
    if os.fileExists(path):
        let content = os.readFile(path)
        if len(content) > 0:
            lines = splitLinesSimple(content)
    var out = ""
    var found = false
    let encoded = "\"" + escapeConfigValue(value) + "\""
    let newLine = key + " = " + encoded
    for idx in 0..<len(lines):
        let rawLine = lines[idx]
        let trimmed = trimLine(rawLine)
        if len(trimmed) == 0 || trimmed[0] == '#':
            out = out + rawLine + "\n"
            continue
        let eq = findChar(rawLine, '=')
        if eq > 0:
            let keyText = trimLine(__cheng_slice_string(rawLine, 0, eq - 1, false))
            if keyText == key:
                out = out + newLine + "\n"
                found = true
                continue
        out = out + rawLine + "\n"
    if ! found:
        out = out + newLine + "\n"
    os.writeFile(path, out)
    return true

fn writeConfigValueWithProfile(key: str, value: str): bool =
    if len(key) == 0:
        return false
    if hasPrefix(key, "profiles.") || key == "profile":
        return writeConfigValue(key, value)
    var profile = ""
    if activeConfigProfile(profile) && len(profile) > 0:
        # Build incrementally to avoid deep temporary chains.
        var scopedKey: str = "profiles."
        scopedKey = scopedKey + profile
        scopedKey = scopedKey + "."
        scopedKey = scopedKey + key
        return writeConfigValue(scopedKey, value)
    return writeConfigValue(key, value)

fn clearConfigValue(key: str): bool =
    if len(key) == 0:
        return false
    let path = codexConfigPath()
    if len(path) == 0 || ! os.fileExists(path):
        return false
    let content = os.readFile(path)
    if len(content) == 0:
        return false
    let lines = splitLinesSimple(content)
    var out = ""
    for idx in 0..<len(lines):
        let rawLine = lines[idx]
        let trimmed = trimLine(rawLine)
        if len(trimmed) == 0 || trimmed[0] == '#':
            out = out + rawLine + "\n"
            continue
        let eq = findChar(rawLine, '=')
        if eq > 0:
            let keyText = trimLine(__cheng_slice_string(rawLine, 0, eq - 1, false))
            if keyText == key:
                continue
        out = out + rawLine + "\n"
    os.writeFile(path, out)
    return true

fn clearConfigValueWithProfile(key: str): bool =
    if len(key) == 0:
        return false
    if hasPrefix(key, "profiles.") || key == "profile":
        return clearConfigValue(key)
    var profile = ""
    if activeConfigProfile(profile) && len(profile) > 0:
        # Build incrementally to avoid deep temporary chains.
        var scopedKey: str = "profiles."
        scopedKey = scopedKey + profile
        scopedKey = scopedKey + "."
        scopedKey = scopedKey + key
        return clearConfigValue(scopedKey)
    return clearConfigValue(key)

fn stripInlineComment(line: str): str =
    if line == nil:
        return ""
    var inString = false
    var escaped = false
    for idx in 0..<len(line):
        let ch = line[idx]
        if inString:
            if escaped:
                escaped = false
            elif ch == '\\':
                escaped = true
            elif ch == '"':
                inString = false
        else:
            if ch == '"':
                inString = true
            elif ch == '#':
                if idx == 0:
                    return ""
                return trimLine(__cheng_slice_string(line, 0, idx - 1, false))
    return trimLine(line)

fn parseTomlStringValue(raw: str): str =
    let trimmed = trimLine(raw)
    if len(trimmed) == 0:
        return ""
    if trimmed[0] == '"' && trimmed[len(trimmed) - 1] == '"':
        return unescapeConfigValue(trimmed)
    return trimmed

fn parseTomlStringArray(raw: str): str[] =
    var out: str[] = []
    let trimmed = trimLine(raw)
    if len(trimmed) == 0:
        return out
    if trimmed[0] != '[':
        let item = parseTomlStringValue(trimmed)
        if len(item) > 0:
            add(out, item)
        return out
    var cursor: int32 = 1
    for idx in cursor..<len(trimmed):
        if idx < cursor:
            continue
        cursor = idx
        for scan in cursor..<len(trimmed):
            if ! isSpace(trimmed[scan]):
                cursor = scan
                break
            if scan == len(trimmed) - 1:
                cursor = len(trimmed)
        if cursor >= len(trimmed) || trimmed[cursor] == ']':
            break
        var item = ""
        let ch = trimmed[cursor]
        if ch == '"':
            var escaped = false
            var nextCursor = cursor + 1
            for scan in cursor + 1..<len(trimmed):
                let c = trimmed[scan]
                if escaped:
                    if c == 'n':
                        item = item + "\n"
                    elif c == 'r':
                        item = item + "\r"
                    elif c == 't':
                        item = item + "\t"
                    else:
                        item = item + $ c
                    escaped = false
                elif c == '\\':
                    escaped = true
                elif c == '"':
                    nextCursor = scan + 1
                    break
                else:
                    item = item + $ c
                nextCursor = scan + 1
            cursor = nextCursor
        else:
            let start = cursor
            var nextCursor = cursor
            for scan in cursor..<len(trimmed):
                let c = trimmed[scan]
                if c == ',' || c == ']':
                    nextCursor = scan
                    break
                nextCursor = scan + 1
            if nextCursor > start:
                item = trimLine(__cheng_slice_string(trimmed, start, nextCursor - 1, false))
            cursor = nextCursor
        if len(item) > 0:
            add(out, item)
        var sawSep = false
        for scan in cursor..<len(trimmed):
            let c = trimmed[scan]
            if c == ',' || c == ']':
                cursor = scan
                sawSep = true
                break
            cursor = scan + 1
        if ! sawSep:
            break
        if cursor < len(trimmed) && trimmed[cursor] == ',':
            cursor = cursor + 1
            continue
        if cursor < len(trimmed) && trimmed[cursor] == ']':
            break
    return out

fn normalizeApprovalPolicyValue(value: str): str =
    let normalized = normalizePolicy(trimLine(value))
    if len(normalized) == 0:
        return ""
    if normalized == "untrusted" || normalized == "unless-trusted" || normalized == "unlesstrusted":
        return "untrusted"
    if normalized == "on-request" || normalized == "onrequest":
        return "on-request"
    if normalized == "on-failure" || normalized == "onfailure":
        return "on-failure"
    if normalized == "never":
        return "never"
    return normalized

fn normalizeSandboxModeValue(value: str): str =
    let normalized = normalizePolicy(trimLine(value))
    if len(normalized) == 0:
        return ""
    if normalized == "read-only" || normalized == "readonly":
        return "read-only"
    if normalized == "workspace-write" || normalized == "workspacewrite":
        return "workspace-write"
    if normalized == "danger-full-access" || normalized == "dangerfullaccess":
        return "danger-full-access"
    return normalized

fn addUniqueString(items: var str[], value: str) =
    if len(value) == 0:
        return
    for idx in 0..<items.len:
        if items[idx] == value:
            return
    add(items, value)

fn requirementsTomlPath(): str =
    let windowsPath = "C:\\etc\\codex\\requirements.toml"
    if os.fileExists(windowsPath):
        return windowsPath
    let unixPath = "/etc/codex/requirements.toml"
    if os.fileExists(unixPath):
        return unixPath
    return ""

fn managedConfigTomlPath(): str =
    let windowsPath = "C:\\etc\\codex\\managed_config.toml"
    if os.fileExists(windowsPath):
        return windowsPath
    let unixPath = "/etc/codex/managed_config.toml"
    if os.fileExists(unixPath):
        return unixPath
    return ""

fn parseRequirementsToml(content: str, outApproval: var str[], outSandbox: var str[]) =
    let lines = splitLinesSimple(content)
    for idx in 0..<len(lines):
        let line = stripInlineComment(lines[idx])
        if len(line) == 0:
            continue
        let eq = findChar(line, '=')
        if eq <= 0:
            continue
        let keyText = trimLine(__cheng_slice_string(line, 0, eq - 1, false))
        if len(keyText) == 0:
            continue
        var valueText: str = ""
        if eq + 1 <= len(line) - 1:
            valueText = trimLine(__cheng_slice_string(line, eq + 1, len(line) - 1, false))
        if keyText == "allowed_approval_policies" && outApproval.len == 0:
            let items = parseTomlStringArray(valueText)
            for itemIdx in 0..<len(items):
                let normalized = normalizeApprovalPolicyValue(items[itemIdx])
                addUniqueString(outApproval, normalized)
        elif keyText == "allowed_sandbox_modes" && outSandbox.len == 0:
            let items = parseTomlStringArray(valueText)
            for itemIdx in 0..<len(items):
                let normalized = normalizeSandboxModeValue(items[itemIdx])
                addUniqueString(outSandbox, normalized)

fn parseLegacyManagedConfig(content: str, outApproval: var str[], outSandbox: var str[]) =
    let lines = splitLinesSimple(content)
    for idx in 0..<len(lines):
        let line = stripInlineComment(lines[idx])
        if len(line) == 0:
            continue
        let eq = findChar(line, '=')
        if eq <= 0:
            continue
        let keyText = trimLine(__cheng_slice_string(line, 0, eq - 1, false))
        if len(keyText) == 0:
            continue
        var valueText: str = ""
        if eq + 1 <= len(line) - 1:
            valueText = trimLine(__cheng_slice_string(line, eq + 1, len(line) - 1, false))
        if keyText == "approval_policy" && outApproval.len == 0:
            let normalized = normalizeApprovalPolicyValue(parseTomlStringValue(valueText))
            addUniqueString(outApproval, normalized)
        elif keyText == "sandbox_mode" && outSandbox.len == 0:
            let normalized = normalizeSandboxModeValue(parseTomlStringValue(valueText))
            if len(normalized) > 0:
                addUniqueString(outSandbox, "read-only")
                if normalized != "read-only":
                    addUniqueString(outSandbox, normalized)

fn readConfigRequirements(outApproval: var str[], outSandbox: var str[]): bool =
    outApproval = []
    outSandbox = []
    let requirementsPath = requirementsTomlPath()
    if len(requirementsPath) > 0:
        let content = os.readFile(requirementsPath)
        if len(content) > 0:
            parseRequirementsToml(content, outApproval, outSandbox)
    let managedPath = managedConfigTomlPath()
    if (outApproval.len == 0 || outSandbox.len == 0) && len(managedPath) > 0:
        let content = os.readFile(managedPath)
        if len(content) > 0:
            parseLegacyManagedConfig(content, outApproval, outSandbox)
    return outApproval.len > 0 || outSandbox.len > 0
