# Config helpers for codex-cheng

import std/os
import std/strings
import seqs
import cheng/codex/common
import system
fn isSpace(ch: char): bool =
    ch == ' ' || ch == '\t' || ch == '\r' || ch == '\n'

fn trimLine(text: str): str =
    if text == nil:
        return ""
    var start: int32 = 0
    var stop: int32 = len(text) - 1
    while start <= stop && isSpace(text[start]):
        start = start + 1
    while stop >= start && isSpace(text[stop]):
        stop = stop - 1
    if start > stop:
        return ""
    # Return an owned string: slice views can dangle once the source buffer drops.
    return "" + __cheng_slice_string(text, start, stop, false)

fn splitLinesSimple(text: str): seq[str] =
    var out: seq[str] = newSeq[str]()
    var start: int32 = 0
    var i: int32 = 0
    while i < len(text):
        if text[i] == '\n':
            var endIdx: int32 = i - 1
            if endIdx >= start && text[endIdx] == '\r':
                endIdx = endIdx - 1
            if endIdx >= start:
                seqAdd(out, "" + __cheng_slice_string(text, start, endIdx, false))
            else:
                seqAdd(out, "")
            start = i + 1
        i = i + 1
    if start <= len(text) - 1:
        seqAdd(out, "" + __cheng_slice_string(text, start, len(text) - 1, false))
    elif start == len(text):
        seqAdd(out, "")
    return out

var configOverrideKeys: seq[str] = newSeq[str]()
var configOverrideValues: seq[str] = newSeq[str]()

fn clearConfigOverrides() =
    configOverrideKeys = newSeq[str]()
    configOverrideValues = newSeq[str]()

fn addConfigOverride(key: str, value: str) =
    if len(key) == 0:
        return
    seqAdd(configOverrideKeys, key)
    seqAdd(configOverrideValues, value)

fn findConfigOverrideIndex(key: str): int32 =
    var idx: int32 = 0
    while idx < len(configOverrideKeys):
        if get(configOverrideKeys, idx) == key:
            return idx
        idx = idx + 1
    return -1

fn setConfigOverrides(overrides: seq[str]) =
    clearConfigOverrides()
    var idx: int32 = 0
    while idx < len(overrides):
        let raw = get(overrides, idx)
        let eq = findChar(raw, '=')
        if eq > 0:
            let keyText = trimLine(__cheng_slice_string(raw, 0, eq - 1, false))
            let valueText = trimLine(__cheng_slice_string(raw, eq + 1, len(raw) - 1, false))
            # codex-rs parses the `value` portion as TOML. We don't implement a full TOML
            # parser here, but we must at least unquote/escape string literals so
            # `-c model="o3"` behaves like `model=o3`.
            addConfigOverride(keyText, unescapeConfigValue(valueText))
        idx = idx + 1

fn configOverrideValue(key: str, outValue: var str): bool =
    if len(key) == 0:
        return false
    var idx: int32 = len(configOverrideKeys) - 1
    while idx >= 0:
        if get(configOverrideKeys, idx) == key:
            outValue = get(configOverrideValues, idx)
            return true
        idx = idx - 1
    return false

fn findChar(text: str, needle: char): int32 =
    var i: int32 = 0
    while i < len(text):
        if text[i] == needle:
            return i
        i = i + 1
    return -1

fn unescapeConfigValue(raw: str): str =
    let trimmed = trimLine(raw)
    if len(trimmed) < 2:
        return trimmed
    if trimmed[0] != '"' || trimmed[len(trimmed) - 1] != '"':
        return trimmed
    var outVal = ""
    var i: int32 = 1
    let endIdx: int32 = len(trimmed) - 1
    while i < endIdx:
        let ch = trimmed[i]
        if ch == '\\' && i + 1 < endIdx:
            let next = trimmed[i + 1]
            if next == 'n':
                outVal = outVal + "\n"
            elif next == 'r':
                outVal = outVal + "\r"
            elif next == 't':
                outVal = outVal + "\t"
            else:
                outVal = outVal + $ next
            i = i + 2
            continue
        outVal = outVal + $ ch
        i = i + 1
    return outVal

fn escapeConfigValue(value: str): str =
    if value == nil:
        return ""
    var outVal = ""
    var i: int32 = 0
    while i < len(value):
        let ch = value[i]
        if ch == '\\':
            outVal = outVal + "\\\\"
        elif ch == '"':
            outVal = outVal + "\\\""
        elif ch == '\n':
            outVal = outVal + "\\n"
        elif ch == '\r':
            outVal = outVal + "\\r"
        elif ch == '\t':
            outVal = outVal + "\\t"
        else:
            outVal = outVal + $ ch
        i = i + 1
    return outVal

fn codexHomeDir(): str =
    let envHome = os.getEnv("CODEX_HOME")
    if len(envHome) > 0:
        return envHome
    let home = os.getEnv("HOME")
    if len(home) > 0:
        let preferred = os.joinPath(home, ".codex-cheng")
        let legacy = os.joinPath(home, ".codex")
        let preferredCfg = os.joinPath(preferred, "config.toml")
        let preferredAuth = os.joinPath(preferred, "auth.json")
        let legacyCfg = os.joinPath(legacy, "config.toml")
        let legacyAuth = os.joinPath(legacy, "auth.json")
        # If the user has explicitly configured `.codex-cheng`, use it. Otherwise,
        # prefer existing Codex state under `.codex` for 1:1 parity.
        if os.fileExists(preferredCfg) || os.fileExists(preferredAuth):
            return preferred
        if os.fileExists(legacyCfg) || os.fileExists(legacyAuth) || os.dirExists(legacy):
            return legacy
        return preferred
    return os.joinPath(currentDirSafe(), ".codex")

fn codexThreadsDir(): str =
    return os.joinPath(codexHomeDir(), "threads")

fn codexConfigPath(): str =
    return os.joinPath(codexHomeDir(), "config.toml")

fn codexAuthJsonPath(): str =
    return os.joinPath(codexHomeDir(), "auth.json")

fn writeAuthJsonApiKey(token: str): bool =
    if len(token) == 0:
        return false
    let home = codexHomeDir()
    if len(home) == 0:
        return false
    if ! os.dirExists(home):
        os.createDir(home)
    let path = codexAuthJsonPath()
    let content = "{\n  \"OPENAI_API_KEY\": " + jstrString(token) + "\n}\n"
    os.writeFile(path, content)
    return true

fn clearAuthJson(): bool =
    let path = codexAuthJsonPath()
    if len(path) == 0:
        return false
    if os.fileExists(path):
        os.removeFile(path)
    return true

fn readConfigValueRaw(key: str, outValue: var str): bool =
    outValue = ""
    if len(key) == 0:
        return false
    let path = codexConfigPath()
    if len(path) == 0 || ! os.fileExists(path):
        return false
    let content = os.readFile(path)
    if len(content) == 0:
        return false
    let lines = splitLinesSimple(content)
    var idx: int32 = 0
    while idx < len(lines):
        let line = trimLine(get(lines, idx))
        if len(line) == 0 || line[0] == '#':
            idx = idx + 1
            continue
        let eq = findChar(line, '=')
        if eq <= 0:
            idx = idx + 1
            continue
        let keyText = trimLine(__cheng_slice_string(line, 0, eq - 1, false))
        if keyText == key:
            if eq + 1 <= len(line) - 1:
                let valueText = trimLine(__cheng_slice_string(line, eq + 1, len(line) - 1, false))
                outValue = unescapeConfigValue(valueText)
            return true
        idx = idx + 1
    return false

fn activeConfigProfile(outProfile: var str): bool =
    outProfile = ""
    var overrideProfile = ""
    if configOverrideValue("config_profile", overrideProfile):
        outProfile = overrideProfile
        return len(overrideProfile) > 0
    if configOverrideValue("profile", overrideProfile):
        outProfile = overrideProfile
        return len(overrideProfile) > 0
    var fileProfile = ""
    if readConfigValueRaw("profile", fileProfile):
        outProfile = fileProfile
        return len(fileProfile) > 0
    return false

fn readConfigValue(key: str): str =
    if len(key) == 0:
        return ""
    var overrideValue = ""
    if configOverrideValue(key, overrideValue):
        return overrideValue
    var profile = ""
    if len(key) > 0 && ! hasPrefix(key, "profiles.") && key != "profile":
        if activeConfigProfile(profile) && len(profile) > 0:
            var profileValue = ""
            # Build incrementally to avoid deep temporary chains.
            var scopedKey: str = "profiles."
            scopedKey = scopedKey + profile
            scopedKey = scopedKey + "."
            scopedKey = scopedKey + key
            if readConfigValueRaw(scopedKey, profileValue):
                return profileValue
    var rawValue = ""
    if readConfigValueRaw(key, rawValue):
        return rawValue
    return ""

fn writeConfigValue(key: str, value: str): bool =
    if len(key) == 0:
        return false
    let home = codexHomeDir()
    if len(home) == 0:
        return false
    if ! os.dirExists(home):
        os.createDir(home)
    let path = codexConfigPath()
    var lines: seq[str] = newSeq[str]()
    if os.fileExists(path):
        let content = os.readFile(path)
        if len(content) > 0:
            lines = splitLinesSimple(content)
    var out = ""
    var found = false
    var idx: int32 = 0
    let encoded = "\"" + escapeConfigValue(value) + "\""
    let newLine = key + " = " + encoded
    while idx < len(lines):
        let rawLine = get(lines, idx)
        let trimmed = trimLine(rawLine)
        if len(trimmed) == 0 || trimmed[0] == '#':
            out = out + rawLine + "\n"
            idx = idx + 1
            continue
        let eq = findChar(rawLine, '=')
        if eq > 0:
            let keyText = trimLine(__cheng_slice_string(rawLine, 0, eq - 1, false))
            if keyText == key:
                out = out + newLine + "\n"
                found = true
                idx = idx + 1
                continue
        out = out + rawLine + "\n"
        idx = idx + 1
    if ! found:
        out = out + newLine + "\n"
    os.writeFile(path, out)
    return true

fn writeConfigValueWithProfile(key: str, value: str): bool =
    if len(key) == 0:
        return false
    if hasPrefix(key, "profiles.") || key == "profile":
        return writeConfigValue(key, value)
    var profile = ""
    if activeConfigProfile(profile) && len(profile) > 0:
        # Build incrementally to avoid deep temporary chains.
        var scopedKey: str = "profiles."
        scopedKey = scopedKey + profile
        scopedKey = scopedKey + "."
        scopedKey = scopedKey + key
        return writeConfigValue(scopedKey, value)
    return writeConfigValue(key, value)

fn clearConfigValue(key: str): bool =
    if len(key) == 0:
        return false
    let path = codexConfigPath()
    if len(path) == 0 || ! os.fileExists(path):
        return false
    let content = os.readFile(path)
    if len(content) == 0:
        return false
    let lines = splitLinesSimple(content)
    var out = ""
    var idx: int32 = 0
    while idx < len(lines):
        let rawLine = get(lines, idx)
        let trimmed = trimLine(rawLine)
        if len(trimmed) == 0 || trimmed[0] == '#':
            out = out + rawLine + "\n"
            idx = idx + 1
            continue
        let eq = findChar(rawLine, '=')
        if eq > 0:
            let keyText = trimLine(__cheng_slice_string(rawLine, 0, eq - 1, false))
            if keyText == key:
                idx = idx + 1
                continue
        out = out + rawLine + "\n"
        idx = idx + 1
    os.writeFile(path, out)
    return true

fn clearConfigValueWithProfile(key: str): bool =
    if len(key) == 0:
        return false
    if hasPrefix(key, "profiles.") || key == "profile":
        return clearConfigValue(key)
    var profile = ""
    if activeConfigProfile(profile) && len(profile) > 0:
        # Build incrementally to avoid deep temporary chains.
        var scopedKey: str = "profiles."
        scopedKey = scopedKey + profile
        scopedKey = scopedKey + "."
        scopedKey = scopedKey + key
        return clearConfigValue(scopedKey)
    return clearConfigValue(key)

fn stripInlineComment(line: str): str =
    if line == nil:
        return ""
    var inString = false
    var escaped = false
    var idx: int32 = 0
    while idx < len(line):
        let ch = line[idx]
        if inString:
            if escaped:
                escaped = false
            elif ch == '\\':
                escaped = true
            elif ch == '"':
                inString = false
        else:
            if ch == '"':
                inString = true
            elif ch == '#':
                if idx == 0:
                    return ""
                return trimLine(__cheng_slice_string(line, 0, idx - 1, false))
        idx = idx + 1
    return trimLine(line)

fn parseTomlStringValue(raw: str): str =
    let trimmed = trimLine(raw)
    if len(trimmed) == 0:
        return ""
    if trimmed[0] == '"' && trimmed[len(trimmed) - 1] == '"':
        return unescapeConfigValue(trimmed)
    return trimmed

fn parseTomlStringArray(raw: str): seq[str] =
    var out: seq[str] = newSeq[str]()
    let trimmed = trimLine(raw)
    if len(trimmed) == 0:
        return out
    if trimmed[0] != '[':
        let item = parseTomlStringValue(trimmed)
        if len(item) > 0:
            seqAdd(out, item)
        return out
    var idx: int32 = 1
    while idx < len(trimmed):
        while idx < len(trimmed) && isSpace(trimmed[idx]):
            idx = idx + 1
        if idx >= len(trimmed) || trimmed[idx] == ']':
            break
        var item = ""
        let ch = trimmed[idx]
        if ch == '"':
            idx = idx + 1
            var escaped = false
            while idx < len(trimmed):
                let c = trimmed[idx]
                if escaped:
                    if c == 'n':
                        item = item + "\n"
                    elif c == 'r':
                        item = item + "\r"
                    elif c == 't':
                        item = item + "\t"
                    else:
                        item = item + $ c
                    escaped = false
                elif c == '\\':
                    escaped = true
                elif c == '"':
                    idx = idx + 1
                    break
                else:
                    item = item + $ c
                idx = idx + 1
        else:
            let start = idx
            while idx < len(trimmed):
                let c = trimmed[idx]
                if c == ',' || c == ']':
                    break
                idx = idx + 1
            if idx > start:
                item = trimLine(__cheng_slice_string(trimmed, start, idx - 1, false))
        if len(item) > 0:
            seqAdd(out, item)
        while idx < len(trimmed) && trimmed[idx] != ',' && trimmed[idx] != ']':
            idx = idx + 1
        if idx < len(trimmed) && trimmed[idx] == ',':
            idx = idx + 1
            continue
        if idx < len(trimmed) && trimmed[idx] == ']':
            break
    return out

fn normalizeApprovalPolicyValue(value: str): str =
    let normalized = normalizePolicy(trimLine(value))
    if len(normalized) == 0:
        return ""
    if normalized == "untrusted" || normalized == "unless-trusted" || normalized == "unlesstrusted":
        return "untrusted"
    if normalized == "on-request" || normalized == "onrequest":
        return "on-request"
    if normalized == "on-failure" || normalized == "onfailure":
        return "on-failure"
    if normalized == "never":
        return "never"
    return normalized

fn normalizeSandboxModeValue(value: str): str =
    let normalized = normalizePolicy(trimLine(value))
    if len(normalized) == 0:
        return ""
    if normalized == "read-only" || normalized == "readonly":
        return "read-only"
    if normalized == "workspace-write" || normalized == "workspacewrite":
        return "workspace-write"
    if normalized == "danger-full-access" || normalized == "dangerfullaccess":
        return "danger-full-access"
    return normalized

fn addUniqueString(items: var seq[str], value: str) =
    if len(value) == 0:
        return
    var idx: int32 = 0
    while idx < len(items):
        if get(items, idx) == value:
            return
        idx = idx + 1
    seqAdd(items, value)

fn requirementsTomlPath(): str =
    let windowsPath = "C:\\etc\\codex\\requirements.toml"
    if os.fileExists(windowsPath):
        return windowsPath
    let unixPath = "/etc/codex/requirements.toml"
    if os.fileExists(unixPath):
        return unixPath
    return ""

fn managedConfigTomlPath(): str =
    let windowsPath = "C:\\etc\\codex\\managed_config.toml"
    if os.fileExists(windowsPath):
        return windowsPath
    let unixPath = "/etc/codex/managed_config.toml"
    if os.fileExists(unixPath):
        return unixPath
    return ""

fn parseRequirementsToml(content: str, outApproval: var seq[str], outSandbox: var seq[str]) =
    let lines = splitLinesSimple(content)
    var idx: int32 = 0
    while idx < len(lines):
        let line = stripInlineComment(get(lines, idx))
        if len(line) == 0:
            idx = idx + 1
            continue
        let eq = findChar(line, '=')
        if eq <= 0:
            idx = idx + 1
            continue
        let keyText = trimLine(__cheng_slice_string(line, 0, eq - 1, false))
        if len(keyText) == 0:
            idx = idx + 1
            continue
        var valueText: str = ""
        if eq + 1 <= len(line) - 1:
            valueText = trimLine(__cheng_slice_string(line, eq + 1, len(line) - 1, false))
        if keyText == "allowed_approval_policies" && len(outApproval) == 0:
            let items = parseTomlStringArray(valueText)
            var itemIdx: int32 = 0
            while itemIdx < len(items):
                let normalized = normalizeApprovalPolicyValue(get(items, itemIdx))
                addUniqueString(outApproval, normalized)
                itemIdx = itemIdx + 1
        elif keyText == "allowed_sandbox_modes" && len(outSandbox) == 0:
            let items = parseTomlStringArray(valueText)
            var itemIdx: int32 = 0
            while itemIdx < len(items):
                let normalized = normalizeSandboxModeValue(get(items, itemIdx))
                addUniqueString(outSandbox, normalized)
                itemIdx = itemIdx + 1
        idx = idx + 1

fn parseLegacyManagedConfig(content: str, outApproval: var seq[str], outSandbox: var seq[str]) =
    let lines = splitLinesSimple(content)
    var idx: int32 = 0
    while idx < len(lines):
        let line = stripInlineComment(get(lines, idx))
        if len(line) == 0:
            idx = idx + 1
            continue
        let eq = findChar(line, '=')
        if eq <= 0:
            idx = idx + 1
            continue
        let keyText = trimLine(__cheng_slice_string(line, 0, eq - 1, false))
        if len(keyText) == 0:
            idx = idx + 1
            continue
        var valueText: str = ""
        if eq + 1 <= len(line) - 1:
            valueText = trimLine(__cheng_slice_string(line, eq + 1, len(line) - 1, false))
        if keyText == "approval_policy" && len(outApproval) == 0:
            let normalized = normalizeApprovalPolicyValue(parseTomlStringValue(valueText))
            addUniqueString(outApproval, normalized)
        elif keyText == "sandbox_mode" && len(outSandbox) == 0:
            let normalized = normalizeSandboxModeValue(parseTomlStringValue(valueText))
            if len(normalized) > 0:
                addUniqueString(outSandbox, "read-only")
                if normalized != "read-only":
                    addUniqueString(outSandbox, normalized)
        idx = idx + 1

fn readConfigRequirements(outApproval: var seq[str], outSandbox: var seq[str]): bool =
    outApproval = newSeq[str]()
    outSandbox = newSeq[str]()
    let requirementsPath = requirementsTomlPath()
    if len(requirementsPath) > 0:
        let content = os.readFile(requirementsPath)
        if len(content) > 0:
            parseRequirementsToml(content, outApproval, outSandbox)
    let managedPath = managedConfigTomlPath()
    if (len(outApproval) == 0 || len(outSandbox) == 0) && len(managedPath) > 0:
        let content = os.readFile(managedPath)
        if len(content) > 0:
            parseLegacyManagedConfig(content, outApproval, outSandbox)
    return len(outApproval) > 0 || len(outSandbox) > 0
