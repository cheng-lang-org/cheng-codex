# Minimal JSON helpers for codex-cheng

import system
import seqs

fn ord(ch: char): int32 =
    return int32(ch)

fn jsonJoinPartsBalanced(parts: str[]): str =
    # Balanced join avoids O(n^2) growth when concatenating many pieces.
    if len(parts) == 0:
        return ""
    if len(parts) == 1:
        let only: str = get[str](parts, 0)
        if only == nil:
            return ""
        return "" + only
    var work: str[] = newSeq[str]()
    var i: int32 = 0
    while i < len(parts):
        let part: str = get[str](parts, i)
        if part == nil:
            seqAdd(work, "")
        else:
            seqAdd(work, part)
        i = i + 1
    while len(work) > 1:
        var next: str[] = newSeq[str]()
        var j: int32 = 0
        while j < len(work):
            if j + 1 < len(work):
                var merged: str = get[str](work, j)
                merged = merged + get[str](work, j + 1)
                seqAdd(next, merged)
                j = j + 2
            else:
                seqAdd(next, get[str](work, j))
                j = j + 1
        work = next
    let out: str = get[str](work, 0)
    if out == nil:
        return ""
    return "" + out

fn jstrEscape(value: str): str =
    if value == nil:
        return ""
    # Build via slices + balanced join to avoid O(n^2) growth and deep `+` chains.
    var parts: str[] = newSeq[str]()
    var last: int32 = 0
    var i: int32 = 0
    while i < len(value):
        let ch: char = value[i]
        if ch == '"' || ch == '\\' || ch == '\n' || ch == '\r' || ch == '\t':
            if i > last:
                let chunk: str = __cheng_slice_string(value, last, i - 1, false)
                seqAdd(parts, chunk)
            if ch == '"':
                seqAdd(parts, "\\\"")
            elif ch == '\\':
                seqAdd(parts, "\\\\")
            elif ch == '\n':
                seqAdd(parts, "\\n")
            elif ch == '\r':
                seqAdd(parts, "\\r")
            else:
                seqAdd(parts, "\\t")
            last = i + 1
        i = i + 1
    if last <= len(value) - 1:
        let tail: str = __cheng_slice_string(value, last, len(value) - 1, false)
        seqAdd(parts, tail)
    return jsonJoinPartsBalanced(parts)

fn jstrString(value: str): str =
    # Build incrementally to avoid deep temporary chains (can SIGSEGV).
    var out = "\""
    out = out + jstrEscape(value)
    out = out + "\""
    return out

fn jstrBool(value: bool): str =
    if value:
        return "true"
    return "false"

fn jstrNull(): str =
    return "null"

fn jstrNumber(value: int64): str =
    return int64ToStr(value)

fn jstrPair(key: str, valueJson: str): str =
    # Build incrementally to avoid deep temporary chains (can SIGSEGV).
    var out = jstrString(key)
    out = out + ":"
    out = out + valueJson
    return out

fn joinWithComma(items: str[]): str =
    if len(items) == 0:
        return ""
    # Use parts + balanced join to avoid quadratic behavior for large arrays.
    var parts: str[] = newSeq[str]()
    var i: int32 = 0
    while i < len(items):
        if i > 0:
            seqAdd(parts, ",")
        let item: str = items[i]
        if item == nil:
            seqAdd(parts, "")
        else:
            seqAdd(parts, item)
        i = i + 1
    return jsonJoinPartsBalanced(parts)

fn jstrObject(pairs: str[]): str =
    # Build incrementally to avoid deep temporary chains (can SIGSEGV).
    var out = "{"
    out = out + joinWithComma(pairs)
    out = out + "}"
    return out

fn jstrArray(items: str[]): str =
    # Build incrementally to avoid deep temporary chains (can SIGSEGV).
    var out = "["
    out = out + joinWithComma(items)
    out = out + "]"
    return out

fn indexOfSubstr(text: str, needle: str, start: int32): int32 =
    if text == nil || needle == nil:
        return -1
    if start < 0:
        return -1
    if len(needle) == 0:
        return start
    var i: int32 = start
    let limit: int32 = len(text) - len(needle)
    while i <= limit:
        var matched = true
        var j: int32 = 0
        while j < len(needle):
            if ord(text[i + j]) != ord(needle[j]):
                matched = false
                break
            j = j + 1
        if matched:
            return i
        i = i + 1
    return -1

fn jsonSkipSpaces(payload: str, startIdx: int32): int32 =
    var idx = startIdx
    while idx < len(payload):
        let ch = payload[idx]
        if ch != ' ' && ch != '\t' && ch != '\n' && ch != '\r':
            break
        idx = idx + 1
    return idx

fn jsonFindKeyAfter(payload: str, key: str, startIdx: int32): int32 =
    let needle = "\"" + key + "\""
    return indexOfSubstr(payload, needle, startIdx)

fn jsonExtractStringAfter(payload: str, key: str, startIdx: int32): str =
    let keyIdx = jsonFindKeyAfter(payload, key, startIdx)
    if keyIdx < 0:
        return ""
    var idx: int32 = indexOfSubstr(payload, ":", keyIdx + len(key) + 2)
    if idx < 0:
        return ""
    idx = jsonSkipSpaces(payload, idx + 1)
    if idx >= len(payload) || payload[idx] != '"':
        return ""
    idx = idx + 1
    var outVal = ""
    while idx < len(payload):
        let ch = payload[idx]
        if ch == '\\':
            if idx + 1 < len(payload):
                let next = payload[idx + 1]
                if next == 'n':
                    outVal = outVal + "\n"
                elif next == 'r':
                    outVal = outVal + "\r"
                elif next == 't':
                    outVal = outVal + "\t"
                else:
                    outVal = outVal + $ next
                idx = idx + 2
                continue
            break
        if ch == '"':
            break
        outVal = outVal + $ ch
        idx = idx + 1
    return outVal

fn jsonExtractString(payload: str, key: str): str =
    return jsonExtractStringAfter(payload, key, 0)

fn jsonFindContainerEnd(payload: str, startIdx: int32, openCh: char, closeCh: char): int32 =
    if payload == nil || startIdx < 0 || startIdx >= len(payload):
        return -1
    if payload[startIdx] != openCh:
        return -1
    var idx = startIdx
    var depth = 0
    var inString = false
    while idx < len(payload):
        let ch = payload[idx]
        if inString:
            if ch == '\\' && idx + 1 < len(payload):
                idx = idx + 2
                continue
            if ch == '"':
                inString = false
            idx = idx + 1
            continue
        if ch == '"':
            inString = true
        elif ch == openCh:
            depth = depth + 1
        elif ch == closeCh:
            depth = depth - 1
            if depth == 0:
                return idx
        idx = idx + 1
    return -1

fn jsonExtractRawFieldAfter(payload: str, key: str, startIdx: int32, expectOpen: char): str =
    let keyIdx = jsonFindKeyAfter(payload, key, startIdx)
    if keyIdx < 0:
        return ""
    var idx: int32 = indexOfSubstr(payload, ":", keyIdx + len(key) + 2)
    if idx < 0:
        return ""
    idx = jsonSkipSpaces(payload, idx + 1)
    if idx < 0 || idx >= len(payload):
        return ""
    if payload[idx] != expectOpen:
        return ""
    var endIdx: int32 = -1
    if expectOpen == '{':
        endIdx = jsonFindContainerEnd(payload, idx, '{', '}')
    elif expectOpen == '[':
        endIdx = jsonFindContainerEnd(payload, idx, '[', ']')
    if endIdx < 0:
        return ""
    return __cheng_slice_string(payload, idx, endIdx, false)

fn jsonExtractRawObjectFieldAfter(payload: str, key: str, startIdx: int32): str =
    return jsonExtractRawFieldAfter(payload, key, startIdx, '{')

fn jsonExtractRawObjectField(payload: str, key: str): str =
    return jsonExtractRawObjectFieldAfter(payload, key, 0)

fn jsonExtractRawArrayFieldAfter(payload: str, key: str, startIdx: int32): str =
    return jsonExtractRawFieldAfter(payload, key, startIdx, '[')

fn jsonExtractRawArrayField(payload: str, key: str): str =
    return jsonExtractRawArrayFieldAfter(payload, key, 0)

fn normalizeCollaborationModeKey(mode: str): str =
    let norm = normalizePolicy(trimLine(mode))
    if norm == "plan":
        return "plan"
    if norm == "execute" || norm == "exec":
        return "execute"
    if norm == "pairprogramming" || norm == "pair_programming" || norm == "pair-programming" || norm == "pair":
        return "pair_programming"
    if norm == "default" || norm == "ask" || norm == "normal":
        return "default"
    return "default"

fn collaborationModeDisplayName(mode: str): str =
    let norm = normalizeCollaborationModeKey(mode)
    if norm == "plan":
        return "Plan"
    if norm == "execute":
        return "Execute"
    if norm == "pair_programming":
        return "Pair Programming"
    return "Default"

fn requestUserInputUnavailableMessage(mode: str): str =
    let modeName = collaborationModeDisplayName(mode)
    return "request_user_input is unavailable in " + modeName + " mode"

fn requestUserInputAvailabilityInstruction(mode: str): str =
    let modeName = collaborationModeDisplayName(mode)
    if normalizeCollaborationModeKey(mode) == "plan":
        return "The `request_user_input` tool is available in " + modeName + " mode."
    return "The `request_user_input` tool is unavailable in " + modeName + " mode. If you call it while in " + modeName + " mode, it will return an error."

fn requestUserInputEmptyResponseJson(): str =
    return jstrObject(seqStr1(jstrPair("answers", jstrObject(newSeq[str]()))))

fn requestUserInputQuestionsFromArguments(arguments: str): str =
    let questions = jsonExtractRawArrayField(arguments, "questions")
    if len(questions) > 0:
        return questions
    return jstrArray(newSeq[str]())

fn requestUserInputNormalizeResponse(resultJson: str): str =
    let answers = jsonExtractRawObjectField(resultJson, "answers")
    if len(answers) == 0:
        return requestUserInputEmptyResponseJson()
    return jstrObject(seqStr1(jstrPair("answers", answers)))

fn jsonFirstNonSpaceIndex(payload: str): int32 =
    if payload == nil:
        return -1
    var i: int32 = 0
    while i < len(payload):
        let ch = payload[i]
        if ch != ' ' && ch != '\t' && ch != '\n' && ch != '\r':
            return i
        i = i + 1
    return -1

fn toolPatchTextFromArguments(arguments: str): str =
    # `apply_patch` can arrive either as JSON (`{"patch":"..."}`) or freeform text.
    # For semantic parity with codex-rs freeform support, accept non-JSON bodies directly.
    let fromJson = jsonExtractString(arguments, "patch")
    if len(fromJson) > 0:
        return fromJson
    let first = jsonFirstNonSpaceIndex(arguments)
    if first < 0:
        return ""
    let ch = arguments[first]
    if ch == '{' || ch == '[' || ch == '"':
        return ""
    return arguments

fn jsonExtractIntAfter(payload: str, key: str, startIdx: int32, defaultValue: int32): int32 =
    let keyIdx = jsonFindKeyAfter(payload, key, startIdx)
    if keyIdx < 0:
        return defaultValue
    var idx: int32 = indexOfSubstr(payload, ":", keyIdx + len(key) + 2)
    if idx < 0:
        return defaultValue
    idx = jsonSkipSpaces(payload, idx + 1)
    var sign = 1
    if idx < len(payload) && payload[idx] == '-':
        sign = -1
        idx = idx + 1
    var value = 0
    var saw = false
    while idx < len(payload):
        let ch = payload[idx]
        if ch < '0' || ch > '9':
            break
        value = value * 10 + (ord(ch) - ord('0'))
        saw = true
        idx = idx + 1
    if ! saw:
        return defaultValue
    return value * sign

fn jsonExtractInt(payload: str, key: str, defaultValue: int32): int32 =
    return jsonExtractIntAfter(payload, key, 0, defaultValue)

fn jsonExtractStringArray(payload: str, key: str): str[] =
    var outVal: str[] = newSeq[str]()
    let keyIdx = jsonFindKeyAfter(payload, key, 0)
    if keyIdx < 0:
        return outVal
    var idx: int32 = indexOfSubstr(payload, ":", keyIdx + len(key) + 2)
    if idx < 0:
        return outVal
    idx = jsonSkipSpaces(payload, idx + 1)
    if idx >= len(payload) || payload[idx] != '[':
        return outVal
    idx = idx + 1
    while idx < len(payload):
        idx = jsonSkipSpaces(payload, idx)
        if idx >= len(payload):
            break
        let ch = payload[idx]
        if ch == ']':
            break
        if ch != '"':
            break
        idx = idx + 1
        # Build via slices + balanced join to avoid O(n^2) growth and to reduce
        # exposure to runtime instability in repeated `value = value + ...`.
        var parts: str[] = newSeq[str]()
        var last: int32 = idx
        while idx < len(payload):
            let c = payload[idx]
            if c == '\\' && idx + 1 < len(payload):
                let next = payload[idx + 1]
                if idx > last:
                    let chunk: str = __cheng_slice_string(payload, last, idx - 1, false)
                    seqAdd(parts, chunk)
                if next == 'n':
                    seqAdd(parts, "\n")
                elif next == 'r':
                    seqAdd(parts, "\r")
                elif next == 't':
                    seqAdd(parts, "\t")
                else:
                    seqAdd(parts, $ next)
                idx = idx + 2
                last = idx
                continue
            if c == '"':
                if idx > last:
                    let chunk: str = __cheng_slice_string(payload, last, idx - 1, false)
                    seqAdd(parts, chunk)
                idx = idx + 1
                break
            idx = idx + 1
        let value: str = jsonJoinPartsBalanced(parts)
        seqAdd(outVal, value)
        while idx < len(payload):
            let sep = payload[idx]
            if sep == ',':
                idx = idx + 1
                break
            if sep == ']':
                break
            idx = idx + 1
    return outVal
