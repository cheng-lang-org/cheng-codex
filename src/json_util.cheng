# Minimal JSON helpers for codex-cheng

import system
import seqs

fn ord(ch: char): int32 =
    return int32(ch)

fn jsonJoinPartsBalanced(parts: str[]): str =
    # Keep this path monomorphize-friendly: use seq_string-specialized access.
    let n: int32 = parts.len
    if n <= 0:
        return ""
    var out: str = ""
    for i in 0..<n:
        let part: str = get_string(parts, i)
        if part != nil:
            out = out + part
    return out

fn jstrEscape(value: str): str =
    if value == nil:
        return ""
    # Build via slices + balanced join to avoid O(n^2) growth and deep `+` chains.
    var parts: str[] = []
    var last: int32 = 0
    for i in 0..<len(value):
        let ch: char = value[i]
        if ch == '"' || ch == '\\' || ch == '\n' || ch == '\r' || ch == '\t':
            if i > last:
                let chunk: str = __cheng_slice_string(value, last, i - 1, false)
                add(parts, chunk)
            if ch == '"':
                add(parts, "\\\"")
            elif ch == '\\':
                add(parts, "\\\\")
            elif ch == '\n':
                add(parts, "\\n")
            elif ch == '\r':
                add(parts, "\\r")
            else:
                add(parts, "\\t")
            last = i + 1
    if last <= len(value) - 1:
        let tail: str = __cheng_slice_string(value, last, len(value) - 1, false)
        add(parts, tail)
    return jsonJoinPartsBalanced(parts)

fn jstrString(value: str): str =
    # Build incrementally to avoid deep temporary chains (can SIGSEGV).
    var out = "\""
    out = out + jstrEscape(value)
    out = out + "\""
    return out

fn jstrBool(value: bool): str =
    if value:
        return "true"
    return "false"

fn jstrNull(): str =
    return "null"

fn jstrNumber(value: int64): str =
    return int64ToStr(value)

fn jstrPair(key: str, valueJson: str): str =
    # Build incrementally to avoid deep temporary chains (can SIGSEGV).
    var out = jstrString(key)
    out = out + ":"
    out = out + valueJson
    return out

fn joinWithComma(items: str[]): str =
    if len(items) == 0:
        return ""
    # Use parts + balanced join to avoid quadratic behavior for large arrays.
    var parts: str[] = []
    for i in 0..<len(items):
        if i > 0:
            add(parts, ",")
        let item: str = items[i]
        if item == nil:
            add(parts, "")
        else:
            add(parts, item)
    return jsonJoinPartsBalanced(parts)

fn jstrObject(pairs: str[]): str =
    # Build incrementally to avoid deep temporary chains (can SIGSEGV).
    var out = "{"
    out = out + joinWithComma(pairs)
    out = out + "}"
    return out

fn jstrArray(items: str[]): str =
    # Build incrementally to avoid deep temporary chains (can SIGSEGV).
    var out = "["
    out = out + joinWithComma(items)
    out = out + "]"
    return out

fn indexOfSubstr(text: str, needle: str, start: int32): int32 =
    if text == nil || needle == nil:
        return -1
    if start < 0:
        return -1
    if len(needle) == 0:
        return start
    if len(text) < len(needle):
        return -1
    let limit = len(text) - len(needle)
    if start > limit:
        return -1
    for i in start..limit:
        var matched = true
        for j in 0..<len(needle):
            if ord(text[i + j]) != ord(needle[j]):
                matched = false
                break
        if matched:
            return i
    return -1

fn jsonSkipSpaces(payload: str, startIdx: int32): int32 =
    var idx = startIdx
    for scan in startIdx..<len(payload):
        let ch = payload[scan]
        if ch != ' ' && ch != '\t' && ch != '\n' && ch != '\r':
            return scan
        idx = scan + 1
    return idx

fn jsonFindKeyAfter(payload: str, key: str, startIdx: int32): int32 =
    let needle = "\"" + key + "\""
    return indexOfSubstr(payload, needle, startIdx)

fn jsonExtractStringAfter(payload: str, key: str, startIdx: int32): str =
    let keyIdx = jsonFindKeyAfter(payload, key, startIdx)
    if keyIdx < 0:
        return ""
    var idx: int32 = indexOfSubstr(payload, ":", keyIdx + len(key) + 2)
    if idx < 0:
        return ""
    idx = jsonSkipSpaces(payload, idx + 1)
    if idx >= len(payload) || payload[idx] != '"':
        return ""
    idx = idx + 1
    var outVal = ""
    var skipUntil: int32 = idx - 1
    for scan in idx..<len(payload):
        if scan <= skipUntil:
            continue
        let ch = payload[scan]
        if ch == '\\':
            if scan + 1 < len(payload):
                let next = payload[scan + 1]
                if next == 'n':
                    outVal = outVal + "\n"
                elif next == 'r':
                    outVal = outVal + "\r"
                elif next == 't':
                    outVal = outVal + "\t"
                else:
                    outVal = outVal + $ next
                skipUntil = scan + 1
                continue
            break
        if ch == '"':
            break
        outVal = outVal + $ ch
    return outVal

fn jsonExtractString(payload: str, key: str): str =
    return jsonExtractStringAfter(payload, key, 0)

fn jsonFindContainerEnd(payload: str, startIdx: int32, openCh: char, closeCh: char): int32 =
    if payload == nil || startIdx < 0 || startIdx >= len(payload):
        return -1
    if payload[startIdx] != openCh:
        return -1
    var depth = 0
    var inString = false
    var skipUntil: int32 = startIdx - 1
    for idx in startIdx..<len(payload):
        if idx <= skipUntil:
            continue
        let ch = payload[idx]
        if inString:
            if ch == '\\' && idx + 1 < len(payload):
                skipUntil = idx + 1
                continue
            if ch == '"':
                inString = false
            continue
        if ch == '"':
            inString = true
        elif ch == openCh:
            depth = depth + 1
        elif ch == closeCh:
            depth = depth - 1
            if depth == 0:
                return idx
    return -1

fn jsonExtractRawFieldAfter(payload: str, key: str, startIdx: int32, expectOpen: char): str =
    let keyIdx = jsonFindKeyAfter(payload, key, startIdx)
    if keyIdx < 0:
        return ""
    var idx: int32 = indexOfSubstr(payload, ":", keyIdx + len(key) + 2)
    if idx < 0:
        return ""
    idx = jsonSkipSpaces(payload, idx + 1)
    if idx < 0 || idx >= len(payload):
        return ""
    if payload[idx] != expectOpen:
        return ""
    var endIdx: int32 = -1
    if expectOpen == '{':
        endIdx = jsonFindContainerEnd(payload, idx, '{', '}')
    elif expectOpen == '[':
        endIdx = jsonFindContainerEnd(payload, idx, '[', ']')
    if endIdx < 0:
        return ""
    return __cheng_slice_string(payload, idx, endIdx, false)

fn jsonExtractRawObjectFieldAfter(payload: str, key: str, startIdx: int32): str =
    return jsonExtractRawFieldAfter(payload, key, startIdx, '{')

fn jsonExtractRawObjectField(payload: str, key: str): str =
    return jsonExtractRawObjectFieldAfter(payload, key, 0)

fn jsonExtractRawArrayFieldAfter(payload: str, key: str, startIdx: int32): str =
    return jsonExtractRawFieldAfter(payload, key, startIdx, '[')

fn jsonExtractRawArrayField(payload: str, key: str): str =
    return jsonExtractRawArrayFieldAfter(payload, key, 0)

fn normalizeCollaborationModeKey(mode: str): str =
    let norm = normalizePolicy(trimLine(mode))
    if norm == "plan":
        return "plan"
    if norm == "execute" || norm == "exec":
        return "execute"
    if norm == "pairprogramming" || norm == "pair_programming" || norm == "pair-programming" || norm == "pair":
        return "pair_programming"
    if norm == "default" || norm == "ask" || norm == "normal":
        return "default"
    return "default"

fn collaborationModeDisplayName(mode: str): str =
    let norm = normalizeCollaborationModeKey(mode)
    if norm == "plan":
        return "Plan"
    if norm == "execute":
        return "Execute"
    if norm == "pair_programming":
        return "Pair Programming"
    return "Default"

fn requestUserInputUnavailableMessage(mode: str): str =
    let modeName = collaborationModeDisplayName(mode)
    return "request_user_input is unavailable in " + modeName + " mode"

fn requestUserInputAvailabilityInstruction(mode: str): str =
    let modeName = collaborationModeDisplayName(mode)
    if normalizeCollaborationModeKey(mode) == "plan":
        return "The `request_user_input` tool is available in " + modeName + " mode."
    return "The `request_user_input` tool is unavailable in " + modeName + " mode. If you call it while in " + modeName + " mode, it will return an error."

fn requestUserInputEmptyResponseJson(): str =
    return jstrObject(seqStr1(jstrPair("answers", jstrObject([]))))

fn requestUserInputQuestionsFromArguments(arguments: str): str =
    let questions = jsonExtractRawArrayField(arguments, "questions")
    if len(questions) > 0:
        return questions
    return jstrArray([])

fn requestUserInputNormalizeResponse(resultJson: str): str =
    let answers = jsonExtractRawObjectField(resultJson, "answers")
    if len(answers) == 0:
        return requestUserInputEmptyResponseJson()
    return jstrObject(seqStr1(jstrPair("answers", answers)))

fn jsonFirstNonSpaceIndex(payload: str): int32 =
    if payload == nil:
        return -1
    for i in 0..<len(payload):
        let ch = payload[i]
        if ch != ' ' && ch != '\t' && ch != '\n' && ch != '\r':
            return i
    return -1

fn toolPatchTextFromArguments(arguments: str): str =
    # `apply_patch` can arrive either as JSON (`{"patch":"..."}`) or freeform text.
    # For semantic parity with codex-rs freeform support, accept non-JSON bodies directly.
    let fromJson = jsonExtractString(arguments, "patch")
    if len(fromJson) > 0:
        return fromJson
    let first = jsonFirstNonSpaceIndex(arguments)
    if first < 0:
        return ""
    let ch = arguments[first]
    if ch == '{' || ch == '[' || ch == '"':
        return ""
    return arguments

fn jsonExtractIntAfter(payload: str, key: str, startIdx: int32, defaultValue: int32): int32 =
    let keyIdx = jsonFindKeyAfter(payload, key, startIdx)
    if keyIdx < 0:
        return defaultValue
    var idx: int32 = indexOfSubstr(payload, ":", keyIdx + len(key) + 2)
    if idx < 0:
        return defaultValue
    idx = jsonSkipSpaces(payload, idx + 1)
    var sign = 1
    if idx < len(payload) && payload[idx] == '-':
        sign = -1
        idx = idx + 1
    var value = 0
    var saw = false
    for scan in idx..<len(payload):
        let ch = payload[scan]
        if ch < '0' || ch > '9':
            break
        value = value * 10 + (ord(ch) - ord('0'))
        saw = true
        idx = scan + 1
    if ! saw:
        return defaultValue
    return value * sign

fn jsonExtractInt(payload: str, key: str, defaultValue: int32): int32 =
    return jsonExtractIntAfter(payload, key, 0, defaultValue)

fn jsonExtractStringArray(payload: str, key: str): str[] =
    var outVal: str[] = []
    let keyIdx = jsonFindKeyAfter(payload, key, 0)
    if keyIdx < 0:
        return outVal
    var idx: int32 = indexOfSubstr(payload, ":", keyIdx + len(key) + 2)
    if idx < 0:
        return outVal
    idx = jsonSkipSpaces(payload, idx + 1)
    if idx >= len(payload) || payload[idx] != '[':
        return outVal
    var cursor = idx + 1
    for idx in cursor..<len(payload):
        if idx < cursor:
            continue
        cursor = jsonSkipSpaces(payload, idx)
        if cursor >= len(payload):
            break
        let ch = payload[cursor]
        if ch == ']':
            break
        if ch != '"':
            break
        cursor = cursor + 1
        # Build via slices + balanced join to avoid O(n^2) growth and to reduce
        # exposure to runtime instability in repeated `value = value + ...`.
        var parts: str[] = []
        var last: int32 = cursor
        var valueEnd = cursor
        var skipUntil: int32 = cursor - 1
        for scan in cursor..<len(payload):
            if scan <= skipUntil:
                continue
            let c = payload[scan]
            if c == '\\' && scan + 1 < len(payload):
                let next = payload[scan + 1]
                if scan > last:
                    let chunk: str = __cheng_slice_string(payload, last, scan - 1, false)
                    add(parts, chunk)
                if next == 'n':
                    add(parts, "\n")
                elif next == 'r':
                    add(parts, "\r")
                elif next == 't':
                    add(parts, "\t")
                else:
                    add(parts, $ next)
                valueEnd = scan + 2
                last = valueEnd
                skipUntil = scan + 1
                continue
            if c == '"':
                if scan > last:
                    let chunk: str = __cheng_slice_string(payload, last, scan - 1, false)
                    add(parts, chunk)
                valueEnd = scan + 1
                break
            valueEnd = scan + 1
        let value: str = jsonJoinPartsBalanced(parts)
        add(outVal, value)
        cursor = valueEnd
        var sawSep = false
        for scan in cursor..<len(payload):
            let sep = payload[scan]
            if sep == ',':
                cursor = scan + 1
                sawSep = true
                break
            if sep == ']':
                cursor = scan
                sawSep = true
                break
            cursor = scan + 1
        if ! sawSep:
            break
    return outVal
